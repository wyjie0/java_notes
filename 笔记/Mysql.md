# 一、查询操作
对于查询处理，可分为逻辑查询处理以及物理查询处理。逻辑查询处理表示执行查询应该产生什么样的结果，而物理查询代表MySQL数据库是如何得到该结果的。
## 逻辑查询处理
在SQL语言中，第一个被处理的子句总是FROM子句。下代码块显示了逻辑查询处理的顺序以及步骤的序号

```
(8) select (9) distinct
(1) from<left_table>
(3) <join_type>join<right_table>
(2) on<join_condition>
(4) where<where_condition>
(5) group by<group_by_list>
(6) with {cube|rollup}
(7) having<having_condition>
(10) order by<order_by_list>
(11) limit <limit_number>
```
每个操作都会产生一张虚拟表，该虚拟表作为一个处理的输入。这些虚拟表对用户是透明的，只有最后一步生成的虚拟表才会返回给用户。具体分析每个阶段：

（1） from：对from子句中的坐标<left_table>和右表<right_table>执行笛卡尔积，产生虚拟表VT1

（2） on：对虚拟表VT1应用on筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2。对于OUTER JOIN中的过滤，在ON过滤器过滤完之后还会添加保留表中被
ON
条件过滤掉的记录

（3） join：如果制定了outer join，那么保留表中为匹配的行作为外部行添加到虚拟表VT2中，产生VT3。如果from子句包含两个以上表，则对上一个连接生成的结果
表VT3和下一个表重复执行步骤1~步骤3，知道处理完所有表为止

（4） where：对VT3应用where过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中。与on过滤器不同，where条件中被过滤掉的记录被永久过滤

（5） group by：根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5

（6） cube|rollup：对表VT5进行cube或rollup操作，产生表VT6

（7） having：对VT6应用having过滤器，只有符合<having_condition>的记录才被插入VT7中

（8） select：选择指定的列，插入到虚拟表VT8中。虽然select是查询中最先被指定的部分，但是知道现在才真正进行处理。有一点容易被忽视的是，**列的别名不能
在select中的其他别名表达式中使用**

（9） distinct：去除重复数据，产生虚拟表VT9

（10） order by：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生VT10。没有order by子句的查询只代表从**集合**中查询数据，而集合是没有顺序
概念的，所以就算有主键按序递增，但是查询的时候，查出的列没有顺序，并不是按主键来取出数据。

（11） limit：取出指定行的记录，产生VT11，并返回给查询用户

## 物理查询处理
数据库可能并不会完全按照逻辑查询处理的方式来进行查询。在MySQL数据库层有Parser和Optimizer两个组件。Parser的工作是分析SQL语句，Optimizer的工作是对
SQL语句进行优化，选择一条最优的路径来选取数据，但是必须保证最终结果与逻辑查询处理是相等的。物理查询可以利用表上的索引来缩短SQL语句运行的时间，一次来
提高数据库的整体性能。

# 二、MySQL体系结构和存储引擎

## 1、MySQL体系结构

数据库是**文件的集合**，是依照某种数据模型组织起来并存放于**二级存储器**中的数据集合

数据库实例是**程序**，是位于用户与操作系统之间的一层数据管理软件，用户对数据库的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道

![image-20200426143614464](F:\Java书和视频\笔记\images\MySQL\1.png)

## 2、MySQL存储引擎

存储引擎是MySQL区别于其他数据库的一个最重要特征，我们可以自定义存储引擎或者修改存储引擎的源代码以供适应于我们自己情况来使用。存储引擎是基于表的，而不是基于数据库的

### 

# 三、InnoDB存储引擎

## 1、InnoDB体系架构

![image-20200427084643846](F:\Java书和视频\笔记\images\MySQL\2.png)

内存池的作用：维护所有进程/线程需要访问的多个内部数据结构；缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存；重做日志缓存

后台线程的作用：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。

### 1.1 后台线程

InnoDB存储引擎是多线程的模型，后台有多个不同的线程，负责处理不同的任务

1. Master Thread

   主要负责将**缓冲池中的数据异步刷新到磁盘**，保证**数据的一致性**，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。

2. IO Thread

   使用AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。IO Thread的工作是负责这些IO请求的回调。

3. Purge Thread

   **事务被提交过后**，其所使用的的undolog可能不再需要，因此需要PurgerThread来回收已经使用并分配的undo页。

4. Page Cleaner Thread

   将之前版本中脏页的刷新操作放入到单独的线程中执行，也就是从Master Thread中把脏页刷新任务提取出来放到这个线程中来执行。目的是减轻原Master Thread的工作及对用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能

### 1.2 内存

1. 缓冲池

   InnoDB存储引擎是**基于磁盘存储**的，并将其中的记录按照==**页**==的方式进行管理。但是由于CPU速度与磁盘速度之间差异很大，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。

   缓冲池中缓存的数据页类型有：**索引页**、**数据页**、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。

   ![image-20200427091412446](F:\Java书和视频\笔记\images\MySQL\3.png)

2. LRU List 、Free List和Flush List

   InnoDB存储引擎如何对缓冲池这么大一个内存区域进行管理？

   数据库中的缓冲池是通过LRU（最近最少使用）算法来进行管理。最频繁使用的页在**LRU列表**的前端，最少使用的页在LRU列表的尾端。当缓冲池不能存放新读到的页时，将首先释放LRU列表的中的尾端的页。

   不过InnoDB存储引擎对LRU算法进行了一些**优化**：在LRU列表中加入了midpoint位置，新读取到的页虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。并把midpoint之后的列表称为old列表，之前的列表称为new列表。

   ==**修改LRU算法的原因：**==若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这种操作为**索引**或**数据的扫描**操作。这类操作需要访问表中的许多页，而这些页通常来说仅仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页的时候，InnoDB存储引擎需要再次访问磁盘。

   在数据库刚启动的时候，页都存放在**Free列表**当中。当需要从缓冲池中分页的时候，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。若没有则删除LRU列表的尾端页

   在LRU列表中存放的页被修改过后，称该页为**脏页**，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而**Flush列表**中的页即为脏页列表。脏页既存在与LRU列表中，又存在与Flush列表中。LRU列表用来**管理缓冲池中页的可用性**，Flush列表用来管理**将页刷新回磁盘**，二者互不影响。

3. 重做日志缓冲

   存储引擎首先将**重做日志信息**放入到这个缓冲区，然后按**一定的频率将其刷新到重做日志文件**。

## 2、CheckPoint技术

当提交事务时，**先写重做日志**（重做日志刷新到磁盘的频率比刷新页的频率要高），**再修改页**。当由于方式宕机而导致数据丢失时，通过重做日志来完成数据的恢复。

CheckPoint技术的目的是解决以下几个问题：

* 缩短数据库的恢复时间
* 缓冲池不够用时，将脏页刷新到磁盘
* 重做日志不可用时，刷新脏页

当数据库放生宕机时，数据库不需要重做所有的日志，因为CheckPoint之前的页都已经刷新回磁盘。故数据库只需对CheckPoint后的重做日志进行恢复。

当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行CheckPoint，将脏页刷回磁盘

## 3、InnoDB关键特性
* 插入缓冲

* 两次写

* 自适应哈希缓冲

* 异步IO

* 刷新邻近页

### 3.1 插入缓冲
Insert Buffer是物理页的一个组成部分。对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，然后再以一定的频率和情况进行Insert Buffer和辅助索引页子结点的合并操作，这时，通常能将多个插入合并到一个操作中。Insert Buffer的使用需要同时满足以下两个条件：索引是辅助索引；索引不是唯一的。

### 3.2 两次写

doublewrite结构如图所示
![image-20200427103744329](F:\Java书和视频\笔记\images\MySQL\4.png)

它由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区，大小也为2MB。在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数**将脏页先复制到内存中的doublewrite buffer**，**之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上**，**然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题**。**在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中。**

如果操作系统在页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。

### 3.3自适应哈希索引

InnoDB会监控对表上各索引页的查询，如果观察到建立哈希索引会带来速度提升，则建立哈希索引，称之为自适应哈希索引（AHI）。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。

AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a,b）这样的联合索引页，其访问模式可以是以下情况：

* where a=xxx
* where a=xxx or b=xxx

==**访问模式一样指的是查询的条件一样**==，若交替进行上述两种查询，那么InnoDB存储引擎不会对该页构造AHI。

### 3.4 刷新邻接页

当刷新一个脏页时，InnoDB存储引擎会检测该页所在**区**的所有页，如果是脏页，那么一起进行刷新。

# 四、文件

## 1、参数文件

MySQL实例可以不需要参数文件，这时所有的参数值取决于编译MySQL时指定的默认值和源代码中指定参数的默认值。

可以使用`show variables`查看数据库中的所以参数，也可以通过`like`来过滤参数名。还可以通过`information_schema`架构下的`GLOBAL_VARIABLES`视图来进行查找。

参数分为动态参数和静态参数，我们可以使用`set`命令对动态参数值进行修改。使用`@@global或@@session`来确定参数修改是基于全局还是基于当前会话。

## 2、日志文件

常见的日志文件有：

* 错误日志
* 二进制日志
* 慢查询日志
* 查询日志

### 2.1 错误日志

错误日志文件对MySQL的启动、运行、关闭过程进行了记录。**在遇到问题时应该首先查看该文件以便定位问题。**通过`show variables like ‘log_error’`来定位该文件

### 2.2 慢查询日志

慢查询日志可帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。

### 2.3 查询日志

记录了所有查询操作

### 2.4 二进制日志

记录了所有的修改操作。作用为：

* 恢复：某些数据的回复需要二进制日志
* 复制：通过复制和执行二进制日志使一台远程的MySQL数据库与一台MySQL数据库进行实时同步
* 审计：审计日志信息，判断是否有对数据库进行注入的攻击

# 五、表
## 1、索引组织表
在InnoDB存储引擎中，表都是根据**主键顺序**组织存放的，这种存储方式的表为**索引组织表**。在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显示地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：

* 首先判断表中是否有==**非空的唯一索引**==，如果有，则该列为主键。当表中有多个非空的唯一索引，则选择第一个定义的为主键。**主键的选择是根据==定义非空唯一索引的顺序==，而不是表中列的顺序**。
* 如果不符合上述条件，InnoDB存储引擎自动创建一个**6字节大小的指针**

创建索引的语句：

* 普通索引：`index`
* 唯一索引：`unique`
* 主键索引：`primary key`

## 2、InnoDB逻辑存储结构
从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间。表空间又由段、区、页组成。
![](F:\Java书和视频\笔记\images\MySQL\5.png)

### 2.1 表空间
表空间可以看做InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，所有的数据都存放在这个表空间中。如果用户启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间中。
### 2.2 段
表空间是由各个段组成的，常见的段有**数据段**、**索引段**、**回滚段**等。==数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。==
### 2.3 区
区是由**连续页**组成的空间，在任何情况下每个区的大小都为1MB。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中有64个连续的页

### 2.4 页

页是InnoDB磁盘管理的最小单位。

### 2.5 行

InnoDB存储引擎是面向列的，也就是说数据是按行进行存放的。

## 3、InnoDB行记录格式
InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据

### 3. 1 Compact行记录格式

目的是为了**高效地存储数据**。一个**页存放的==行数据越多==，其性能越高。**

![image-20200428082616260](F:\Java书和视频\笔记\images\MySQL\6.png)

变长字段长度：最大不能超过2字节，这是因为MySQL数据库中的VARCHAR类型的最大长度限制为65535。

Null标志位：指示该行数据中是否有Null值

每行数据除了用户定义的列外，还有两个隐藏列，**事务ID列**和**回滚指针列**，若InnoDB表没有定义主键，每行还会增加一个rowid列

### 3.2 Redundant行记录格式
![](F:\Java书和视频\笔记\images\MySQL\7.png)

### 3.3 行溢出数据

InnoDB存储引擎可以**将一条记录中的某些数据存储在真正的数据页面之外。**

MySQL官方手册中定义的65535长度是指所有`VARCHAR`列的长度综总和，如果列的长度总和超出这个长度，那么就无法创建。但是由于InnoDB存储引擎的页为16KB，即16384字节，如何存放65535字节的？在一般情况下，InnoDB存储引擎的数据都是存放在页类型为`B-tree node`中，但是当发生行溢出时，数据存放在页类型为`Uncompress BLOB`页中。

### 3.4 `CHAR`的行结构存储

通常理解`VARCHAR`是存储变长长度的字符类型，`CHAR`是存储固定长度的字符类型。现在的MySQL版本中，`CHR(N)`中的N指的是**字符的长度**，而不是之前版本的字节长度。也就说在不同的字符集下，`CHAR`类型列内部存储的可能不是定长的数据。

## 4、InnoDB数据页结构

页类型为`B-tree node`的页存放的就是表中行的实际数据

![image-20200428092312138](F:\Java书和视频\笔记\images\MySQL\8.png)



1. File Header

   用来记录页的一些头信息

2. Page Header

   用来记录数据页的状态信息

3. Infimum和Supremum Record

   在InnoDB存储引擎中，每个页有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下都不会被删除

4. User Record和Free Space

   User Record用于实际存储行记录的内容

## 5、约束

### 5.1 数据完整性

关系数据库本身能保证存储数据的完整性，不需要应用程序的控制。关系数据库是提供了**约束机制**来保证数据库中数据的完整性。

* 实体完整性

  ==**保证表中有一个主键**==，在InnoDB存储引擎中， 用户可以通过定义`Primary Key`或`Unique Key`约束来保证实体的完整性。用户还可以通过编写一个触发器来保证数据完整性。

* 域完整性

  ==**保证数据每列的值满足特定的条件**==。可以通过以下几种途径来保证：

  * 选择合适的数据类型确保一个数据值满足特定条件
  * 外键约束
  * 编写触发器
  * 用`DEFAULT`约束作为强制域完整性

* 参照完整性

  ==**保证两张表之间的关系**==

InnoDB提供了以下几种约束：

* `Primary Key`
* `Unique Key`
* `Foreign Key`
* `Default`
* `NOT NULL`

### 5.2 约束的创建和查找

约束的创建可以采用以下两种方式：

* 表建立时就进行约束定义
* 利用`Alter Table`命令来进行创建约束

### 5.3 ==约束和索引的区别==

当用户创建了一个唯一索引（`Unique Key`）就创建了一个唯一的约束。但是约束和索引的概念还是不同，**约束更是一个逻辑的概念，用来保证数据的完整性**，而==**索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。**==

### 5.4 ENUM和SET约束

MySQL数据库不支持传统的CHECK约束，但是通过ENUM和SET类型可以解决部分这样的需求。例如表上有一个性别类型，规定域的范围只能是female或male，这种情况下用户可以通过ENUM类型来进行约束

## 6、视图

视图是一个命名的虚表，它由一个SQL查询来定义，可以当做表来使用。视图中的数据没有实际的物理存储

### 6.1 视图的作用

视图的主要用途之一是被用作一个抽象装置，对于一些应用程序，程序本身并不关心基表的结构，只需要按照视图定义来取数据或更新数据，因此，视图可以起到一个**安全层**的作用

## 7、分区表

分区可能会给某些SQL语句的性能带来提高，但是分区主要用于数据库高可用性的管理。

当前MySQL数据库支持以下几种类型的分区：

* RANGE分区：行数据基于一个给定连续空间的列值被放入分区

* LIST分区：和RANGE分区类似，只不过存储的是离散的值

* HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能是负数

* KEY分区：根据MySQL数据库提供的哈希函数来进行分区

  **不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。唯一索引可以是允许Null值，并且分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。如果没有定义主键和唯一索引，那么分区列可以指定为任意一列。**

### 7.1 RANGE分区

![image-20200428101923625](F:\Java书和视频\笔记\images\MySQL\9.png)

如果插入的值不再分区的定义中，数据库会抛出异常。

RANGE分区主要用于日期列的分区。

### 7.2 LIST分区

![image-20200428102234070](F:\Java书和视频\笔记\images\MySQL\10.png)

如果是插入多行数据，在插入中间某一条数据时遇到数据不在指定分区定义中，那么如果是MyISAM存储引擎会将该条数据之前的数据插入成功，抛弃掉以后的数据；InnoDB存储引擎会将整个插入操作视为一个事务，因此没有任何数据会插入。

### 7.3 HASH分区

HASH分区的目的是将数据均匀地分布到预先定义的各个分区中，保证个分区的数据数量大致是一样的。

![image-20200428102624643](F:\Java书和视频\笔记\images\MySQL\11.png)

### 7.4 KEY分区

HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行分区。



如果插入Null值，RANGE分区会将NULL值放入最左边的分区；LIST分区需要明确指定NULL属于哪一个分区，不然会报错；HASH分区和KEY分区都会将NULL返回一个0；

# 六、索引与算法
## 1、InnoDB存储引擎索引概述

InnoDB存储引擎支持的索引有：B+树索引、全文索引、哈希索引。其中哈希索引是自适应的，不能人为干预是否在一张表中生成哈希索引

B+树索引并不能找到一个给定键值的具体行。**B+树索引能找到的只是被查找数据行所在的页**。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。

## 2、B+树

B+树由B树和索引顺序访问方法演化而来。

B+树是为磁盘或其他直接存取辅助设备设计的一种**平衡查找树**。在B+树中，**所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。**

![image-20200428110410046](F:\Java书和视频\笔记\images\MySQL\12.png)

## 3、B+树索引

数据库中的B+树索引可以分为聚集索引和辅助索引。这两种的不同支持在于，叶子节点是否存放一整行的信息。

### 3.1 聚集索引

聚集索引就是按照每张表的==**主键**==构造一棵B+树，同时**叶子节点中存放的即为==整张表的行记录数据==**，也将聚集索引的叶子节点称为**数据页**。每张表只能拥有一个聚集索引。

### 3.2 辅助索引

叶子节点并不包含行记录的全部数据。叶子节点除了包含**键值**以外，每个叶子节点中的索引行中还包含了一个**书签**。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对的行记录。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

![image-20200428112907915](F:\Java书和视频\笔记\images\MySQL\13.png)

当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。比如，如果在一棵高度为3的辅助索引树中查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3此查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页

## 4、Cardinality值

### 4.1 什么是Cardinality

并不是在所有的查询条件中出现的列都需要添加索引。如果某个字段的取值范围很广，几乎没有重复，即属于**高选择性**，则此时使用B+树索引是最适合的。

怎么看索引是否是高选择性？可以通过show index结果中的列Cardinality来观察。它表示==**索引中不重复记录数量的预估值**==。在实际应用中，Cardinality / n_rows_in_table应尽可能等于1。如果非常小，那么用户需要考虑是否还有必要创建这个索引。

## 5、索引的使用

### 5.1 联合索引

联合索引是指对表上的多个列进行索引。比如：

```sql
create table t (
	a int,
    b int,
    primary key(a),
    key index_a_b (a, b)
) engine = innodb;
```

上面的`sql`语句创建了一个表`t`，并且索引`index_a_b`是联合索引，联合的列为`(a,b)`。

从本质上来说，联合索引也是一棵B+树，不同的是联合索引的键值数量是大于等于2。

![image-20200428141600951](F:\Java书和视频\笔记\images\MySQL\14.png)

从上图可知多个键值的B+树情况，键值也是排序的。

因此，对于查询`select * from t where a=xxx and b=xxx`，显然是可以使用`(a,b)`这个联合索引的。对于单个的a列查询`select * from t where a=xxx`也可以使用这个`(a,b)`索引。但对于b列的查询`select * from t where b=xxx`，不可以使用这个`(a,b)`索引，我们可以发现，叶子节点上b的值不是排序的。这就是==**最左匹配原则**==。也就是说，从索引列开始，从左往右依次数，**中间不间断**，则能使用索引。





具体可看

* [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

* [数据库两大神器--索引和锁](https://juejin.im/post/5b55b842f265da0f9e589e79)

* [MySQL的索引](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0)

# 七、数据库中的锁

## 1、Lock和Latch

Latch一般称为轻量级锁，因为其要求锁定的时间必须非常短。如果支持的时间长，那么应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制

**Lock的对象是事务**，用来锁定的是数据库中的对象，如表、页、行。并且一般Lock的对象仅在事务commit或rollback后进行释放

**在一个事务中，会用到锁（要么是锁算法，要么显示加锁）。事务使用锁来满足其性质。**

![image-20200429082748805](F:\Java书和视频\笔记\images\MySQL\15.png)

## 2、InnoDB存储引擎中的锁

### 2.1 锁的类型

InnoDB实现了两种标准的行级锁：

* 共享锁（S Lock），允许事务读一行数据
* 排它锁（X Lock），允许事务删除或更新一行数据

![image-20200429083430550](F:\Java书和视频\笔记\images\MySQL\16.png)

InnoDB支持**多粒度锁定**，这种锁定允许事务在行级上的锁和表上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB支持一种额外的锁方式，称之为**意向锁**。意向锁是将锁定的对象分为多个层次，意向锁意味着时序希望在更细粒度上进行加锁。

若将上锁的对象看作一棵树，那么对最下层的对象上锁（更细粒度），首先需要对粗粒度的对象上锁。如果需要对也上的记录`r`进行上`X`锁，那么分别需要对数据库A、表、页上意向锁`IX`，最后对记录`r`上`X`锁。**若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成**

![image-20200429083926211](F:\Java书和视频\笔记\images\MySQL\17.png)

InnoDB的意向锁的设计目的是为了在一个事务中揭示**下一行将被请求的锁类型**。它支持两种意向锁：

* 意向共享锁`IS`，事务想要获得一张表中某几行的共享锁
* 意向排它锁`IX`，事务想要获得一张表中某几行的排它锁

### 2.2 一致性非锁定读

一致性非锁定读是指InnoDB通过**行多版本控制**的方式来读取**当前执行时间**数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时==**读取操作不会因此去等待行上锁的释放**==。它会去**读取行的一个快照数据**。

![image-20200429085011703](F:\Java书和视频\笔记\images\MySQL\18.png)

之所以成为非锁定的读，是因为不需要等待访问的行上X锁的释放。**快照数据是指该行的之前版本的数据。**这种是默认的读取方式，但是在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。

==**一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。**==由此带来的并发控制，称为行多版本并发控制。

在事务隔离级别`READ COMMITTED`和`REPEATABLE READ`下，InnoDB使用非锁定的一致性读。但是它们对快照的定义不同。**在`READ COMMITTED`事务隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据。在`REPEATABLE READ`事务隔离级别下，非一致性读总是读取事务开始时的行版本数据。**

具体分析一个例子：

首先对当前MySQL数据库的连接会话A中执行如下SQL语句：

```sql
#Session A
mysql> BEGIN;

mysql> select * from parent where id = 1;

	id
	1
```

会话A中已通过显示地执行命令BEGIN开启了一个事务，并读取了表parent中id为1的数据，但是事务并没有结束。于此同时，开启另一个会话B：

```sql
mysql> BEGIN;

mysql> update parent set id = 3 where id = 1;
```

在会话B中将事务表parent中id为1的记录修改为3，但是事务同样没有提交，这样id=1的行其实加了一个X锁。这时如果在会话A中再次读取id为1的记录，根据InnoDB存储引擎的特性，在`READ COMMITTED`和`REPEATABLE READ`的事务隔离级别下会使用非锁定的一致性读。回到之前的会话A，接着上次未提交的事务，执行SQL语句`select * from parent where id = 1`的操作，这时不管使用`READ COMMITTED` 还是`REPEATABLE READ`的事务隔离级别，显示的数据都应该是1。（**因为使用的是一致性非锁定读，会话A在读取的时候不会对行数据进行加锁，会话B才可以在事务中对行数据就行修改**）

由于当前id=1的数据被修改过一次，因此只有一个行版本的记录。接着，会话B中提交上次的事务：

```sql
#session B
mysql> committed;
```

在会话B提交事务后，这时在会话A中在运行`select * from parent where id = 1`，**在`READ COMMITTED`级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。**在上述例子中，因为会话B提交了事务，所以`READ COMMITTED`事务隔离级别下回得到如下结果：

```sql
#session A
mysql> select *from parent where id = 1;
Empty set;
```

而对于`REPEATABLE READ`的事务隔离级别，总是读取事务开始时的行数据。因此对于此事务隔离级别，得到的结果如下：

```sql
mysql> select * from parent where id = 1;
+----+
| id |
+----+
|  1 |
+----+
```

也就是说，在`REPEATABLE READ`事务隔离级别下，要求的是**可重复读**，即在一个事务中，只要没有提交，读取到的数据总是一样的，不管另外的事务是否对该数据进行了修改。在提交了事务过后，才会读取到被修改的数据。

### 2.3 一致性锁定读

在默认配置下，即事务隔离级别为`REPEATABLE READ`模式下，InnoDB的select操作使用了一致性非锁定读。但是在某些情况下，用户需要**显示的对数据库读取操作进行加锁**以保证数据逻辑的一致性。这要求数据库支持加锁语句，即使是对于select的只读操作。

InnoDB存储引擎对于select语句支持两种一致性的锁定读操作：

* `select ... for update`
* `select ... lock in share mode`

`select ... for update`对读取的行记录加一个**X锁**，其他事务不能对已锁定的行加上任何锁。`select ... lock in share mode`对读取的行记录加上一个**S锁**，其他事物可以像被锁定的行加S锁，但是如果加X锁，则会被阻塞。**在使用这两个锁定语句时，必须要在一个事务之中**

### 2.4 自增长与锁

在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器进行插入操作时，这个计数器会被初始化。

插入操作会依据这个自增长的计数器加1赋予自增长序列。这个实现方式称作`AUTO-INC Locking`。这种锁其实是采用一种特殊的**表锁机制**，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成**对自增长值插入的SQL语句后立即释放**。

==**在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则MySQL数据库会抛出异常。**==

### 2.5 外键和锁

在InnoDB存储引擎中，对于一个外键列，如果没有显示地对这个列加索引，==**InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁**==

对于外键值的插入或更新，首先需要查询父表中的记录，即select父表，但是对于父表的select操作，不是使用一致性非锁定读的方式，因为这样会方式数据不一致的问题。因此这时使用的是`select ... lock in share mode`方式，即主动对父表加一个S锁。如果这时父表上已经这样加了X锁，子表上的操作会被阻塞。

## 3、锁的算法

### 3.1 行锁的三种算法

InnoDB存储引擎有三种行锁的算法：

* Record Lock：单个行记录上的锁

* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身

* Next-Key Lock： Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

  **Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。**

例如一个索引有10，11，13和20四个值，那么该索引可能被Next-Key Locking的区间为：

```mathematica
(-无穷，10],(10,11],(11,13],(13,20],(20,正无穷)
```

当查询的索引含有**唯一属性**时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。

![image-20200429095802135](F:\Java书和视频\笔记\images\MySQL\19.png)

![image-20200429095736031](F:\Java书和视频\笔记\images\MySQL\20.png)

表t一共有1、2、5三个值。在会话A首先对a=5进行X锁定，而由于a是主键且唯一，因此锁定的仅是5这个值，而不是(2,5]这个范围，这样再会话B中插入值4就不会阻塞，可以立即插入并返回。即锁定有Next-Key Lock算法降级为了Record Lock，从而提高了并发性。

### 3.2 解决Phantom Problem

在默认的事务隔离级别下，即`REPEATABLE READ`下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem（幻影读问题）。在`READ COMMITTED`隔离级别下回产生幻影读问题。

幻影读问题是指在**同一事务**下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会==**返回之前*不存在*的行**==。就是说，之前没有这一行，但是确读到了这一行，就像看错了一样。

比如下面的例子：

表t有一列a，一共有1、2、5三个值（上一节的表）。若这时事务T1执行如下的SQL语句：

`select * from t where a > 2 for update;`

这时事务T1并没有进行提交，上述操作应该返回5。若与此同时，另一个事务T2插入了4这个值，并且数据库允许该操作，那么事务T1再次执行上述SQL语句会得到4和5。这与第一次得到的结果不同，**违反了事务的隔离性**，即当前事务能够看到其他事务的结果。	

InnoDB存储引擎采用Next-Key Locking的算法避免幻影读问题。**对于上述SQL语句`select * from t where a > 2 for update;`，其锁住的不是5这单个值，而是对(2,正无穷)这个范围加了X锁。因此任何对于这个范围的插入都是不允许的，从而避免了幻影读。**

==**InnoDB存储引擎默认的隔离级别是`REPEATABLE READ`，在该隔离级别下，其采用Next-Key Locking的方式来加锁。而在事务隔离级别`READ COMMITTEd`下，其仅采用Record Lock，索引在此级别下会产生幻影读问题。**==

## 4、锁问题

**通过锁机制，可以实现事务的隔离性要求**，使得事务可以并发工作。锁也会带来下面三种问题，如果可以防止这三种情况的发生，那将不会产生并发异常。

### 4.1 脏读

**脏数据是指事务对缓冲池中行记录的修改，并且==还没有提交==。**

如果读到了脏数据，就说明一个事务可以读到另一个事务中未提交的数据，这显然违反了数据库的隔离性。

==**脏读指的是在不同的事务下，当前事务可以读到另外事务未提交的数据。**==

![image-20200429112117262](F:\Java书和视频\笔记\images\MySQL\21.png)

在事务隔离级别`READ UNCOMMITTED`下，会产生脏读的问题。而目前绝大多数的数据库都将隔离级别默认设置为了`READ COMMITTED`。InnoDB存储引擎默认的事务隔离级别为`READ REPEATABLE`。

### 4.2 不可重复读

不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该集合，并做了一些DML操作。因此，**在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的**。在`READ COMMITTED`事务隔离级别下可能会发生这种问题，因为该隔离级别下，读取数据采用的是一致性非锁定读，它会读取最新的数据（或快照）。

![image-20200429112943078](F:\Java书和视频\笔记\images\MySQL\22.png)

在会话B提交事务之前，会话A的事务中不会读取到2，没有发生脏读的现象。但会话B提交事务过后，A中可以读到1和2两条记录。这就发生了不可重复读。

==**在InnoDB存储引擎中，通过使用Next-Key Locking机制来避免不可重复读。在MySQL官方文档中将不可重复读的问题定义为Phantom Problem，即幻读。但是我看网上有人说，幻读注重的是insert操作，因为这样才会读取到不存在的行；而不可重复读注重的是update和delete**==

InnoDB默认的隔离级别就避免了不可重复读的现象。

### 4.3 丢失更新

一个事务的更新（**注重的是update操作**）会被另一个事务的更新操作所覆盖，从而导致数据的不一致。例如：

1. 事务T1将行记录r更新为v1，但是事务T1**未提交**；
2. 与此同时，事务T2将行记录r更新为r2，事务T2**未提交**；
3. 事务T1提交
4. 事务T2提交

但是在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。这是因为，即使是`READ UNCOMMITTEd`的事务隔离级别，对于行的DML操作，需要对**行**或其他粗粒度级别的对象加锁。因此在上述的步骤2中，事务T2并不能对行记录r进行更新操作，其会被阻塞，直到事务T1提交。

要避免丢失更新，需要让事务在这种情况下变成串行化操作。即在上述四个步骤的1中，对用户读取的记录加上一个排它锁。同样，在步骤2中也需要加一个排它锁。（显示加锁）

![image-20200429114504426](F:\Java书和视频\笔记\images\MySQL\23.png)

## 5、死锁

**死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。**若无外力作用，事务都将无法推进下去。

解决死锁的最简单的方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。（对性能影响较大）

除了超时机制，当前数据库都普遍==**采用`wait-for graph`（等待图）机制的方式来进行死锁检测。**==这是一种更为主动的死锁检测方式。该机制要求数据库保存一下两种信息：

* 锁的信息链表
* 事务等待链表

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁。

**InnoDB存储引擎不会回滚大部分的错误异常，但是死锁除外**。发现死锁后，InnoDB存储引擎马上回滚一个事务。

# 八、事务

事务会把数据库从**一种一致状态**转换为**另一种一致状态**。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。

InnoDB存储引擎中的事务完全符合ACID的特性：

* 原子性（atomicity)
* 一致性（consistency)
* 隔离性（isolation）
* 持久性（durability）

## 1、认识事务

**原子性** 原子性是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

**一致性** 一致性是指事务将数据从一种一致性状态转变为下一种一致性状态。==**在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。**==例如，在表中有一个字段为姓名，为唯一约束，即在表中姓名不能重复。如果一个事务对姓名段进行了修改，但是在事务提交或事务操作发生回滚后， 表中的姓名变得不唯一了，这就破坏了事务的一致性要求。

**隔离性** 事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，**通常这使用锁来实现**。

**持久性** 事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。



事务可以分为以下几种：

* 扁平事务
* 带保存点的扁平事务
* 链事务
* 嵌套事务
* 分布式事务

**扁平事务**

所有操作都属于同一层次，有Begin Work开始，有Commit Work或Rollback Work结束，其间的操作是原子的，要么都执行，要么都回滚。

![image-20200429141914435](F:\Java书和视频\笔记\images\MySQL\24.png)

**带保存点的扁平事务**

除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。**保存点**用来通知系统应该记住事务当前的状态。

**链事务**

可视为保存点模式的一种变种。

带有保存点的扁平事务，当系统发生崩溃时，所有的保存点都会消失。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。

链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。**链事务只能恢复到最近的一个保存点。**

**链事务在执行COMMIT后就释放当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。**

## 2、事务的实现

事务隔离性由锁来实现。原子性、一致性、持久性由数据库的redo log和undo log来完成。

## 3、事务控制语句

在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后会马上执行COMMIT操作。要显示地开启一个事务需要使用命令BEGIN，START TRANSACTION或执行命令 SET AUTOCOMMIT=0。

用户可以使用的事务控制语句：

* START TRANSACTION | BEGIN：显示开启一个事务
* COMMIT：提交事务，使对数据库的修改成为永久性的
* ROLLBACK：结束用户的事务，撤销正在进行的所有未提交的修改
* SAVEPOINT identifier：在一个事务中创建一个保存点
* RELEASE SAVEPOINT identifier：删除一个事务的保存点
* ROLLBACK TO [SAVEPOINT] identifier：把事务回滚到保存点，保存点之前的操作不回滚。如果回滚到一个不存在的保存点，会产生异常。而且**它不会真正的结束事务**。

## 4、事务的隔离级别

SQL标准定义的四个隔离级别为：

* READ UNCOMMITTED
* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE

隔离级别越低，事务请求的锁越少或保持锁的时间越短。可以使用指令来设置当前会话或全局的事务隔离级别：

```sql
set [global|session] transaction isolation level {read uncommitted|read committed | repeatable read | serializable}
```

```sql
mysql> select @@tx_isolation #查看当前会话的事务隔离级别
mysql> select @@global.tx_isolation #查看全局的事务隔离级别
```

* 在SERIALIZABLE事务隔离级别下，InnoDB存储引擎会在每个select语句后自动加上lock in share mode，即为每个读取操作加一个共享锁，因此在这种隔离级别下，读操作占用了锁，也就不支持一致性非锁定读。

* 在READ COMMITTED事务隔离级别下，事务没有使用gap lock进行锁定，只是使用了record key来锁定单行，因此在这种情况下会产生不可重复读（幻读）的问题。

## 5、分布式事务

### 5.1 MySQL数据库分布式事务

InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。**全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。**在使用分布式事务时，InnoDB存储引擎的隔离级别必须设置为SERIALIZABLE。

XA事务允许不同数据库之间的分布式事务，只要参与全局事务中的每个节点都支持XA事务。

XA事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。

* 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器
* 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
* 应用程序：定义事务的边界，指定全局事务中的操作。

# 一些文章

* [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

* [数据库两大神器--索引和锁](https://juejin.im/post/5b55b842f265da0f9e589e79)

* [MySQL的索引](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0)

* [超全面MySQL语句加锁分析（上篇）](https://mp.weixin.qq.com/s/wSlNZcQkax-2KZCNEHOYLA)

* [超全面MySQL语句加锁分析（中篇）](https://mp.weixin.qq.com/s/ODbju9fjB5QFEN8IIYp__A)

* [超全面MySQL语句加锁分析（下篇）](https://mp.weixin.qq.com/s/9WWBXLNoUcTkS4DJnM5ViA)

* [MySQL事务隔离级别和MVCC](https://mp.weixin.qq.com/s/Jeg8656gGtkPteYWrG5_Nw)

