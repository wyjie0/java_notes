学习设计模式首先看的《Head First设计模式》这本书，然后看了讲解设计模式的视频。本篇内容大部分来自《Head First 设计模式》

设计模式已经深入的Java、框架源码的各个方面，学习设计模式可以帮助我在阅读源码的时候，理解为什么会进行这样的编码设计，更好的学习源码中的思想。不过实际
编码与经典的书本中的设计模式代码还是会有一定的差别，会有许多改版，需要多看多想。

## 一、UML类图

### 类在类图中的表示方法

在UML类图中，类由一个矩形来表示，矩形中分为三部分，第一部分写类名，第二部分填写类中的属性，第三部分填写类中包含的方法。
![image-20200327111203958](F:\Java书和视频\笔记\images\设计模式\1.png)

* +：表示public
* -：表示private
* #：表示protected
* _下划线：表示static
* 斜体表示抽象

### 类与类之间关系的表示方式

#### 泛化关系（继承关系）

![image-20200327111340083](F:\Java书和视频\笔记\images\设计模式\3.png)



用于描述父类与子类之间的关系，**用带空心三角形的实线来表示这种关系，由子类指向父类**

#### 接口实现关系

![image-20200327111246851](F:\Java书和视频\笔记\images\设计模式\2.png)

用于描述某个类实现某个接口，**用带空心三角形的虚线类表示**

#### 依赖关系

![image-20200327111410048](F:\Java书和视频\笔记\images\设计模式\4.png)

描述一种**使用关系**，特定事物的改变有可能会影响到使用该事物的其他事物。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。**用一条带有箭头的虚线表示**

#### 关联关系

关联关系又可进一步分为单向关联和双向关联

   ##### 单向关联

![image-20200327111429517](F:\Java书和视频\笔记\images\设计模式\5.png)

   描述一个类的某个成员变量是另一个类的实例。**用一个带有箭头的实线来表示**

   ##### 双向关联

    即两个类各种持有对方类型的成员变量，**用不带箭头的实线表示**

#### 聚合关系

![image-20200327111445476](F:\Java书和视频\笔记\images\设计模式\6.png)

聚合关系强调的是“整体”包含“部分”，但是“部分”可以脱离“整体”而独立存在。**用带空心菱形和箭头的实线表示**

#### 组合关系

![image-20200327111552435](F:\Java书和视频\笔记\images\设计模式\7.png)

组合关系和聚合关系之间最大的不同之处在于：“部分”不能脱离“整体”而独立存在，**用带实心菱形和箭头的实线表示**

## 二、设计原则

### 设计模式的七大原则（设计模式为什么这样设计的依据，也是编程时需要遵循的原则）

1. 单一职责原则
   一个类只负责一个职责  
2. 接口隔离原则
   客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。如果一个接口中的方法很多，某个类依赖这个接口时只会使用一部分方法，
   那么就应该把接口拆分成多个接口。
3. 依赖倒转原则
   1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
   2) 抽象不应该依赖细节，细节应该依赖抽象
   3) 依赖倒转的中心思想是面向接口编程
   4) 使用接口或抽象类的目的是制定**规范**，而不设计任何操作，把**展现细节的操作交给它们的实现类**去完成
   **编程时，在遇到依赖的时候，应该通过接口来完成依赖的传递**
   注意事项和细节：
   1) 低层模块（被依赖的模块）尽量都要有抽象类或接口，或者两者都有，这样程序稳定性更好
   2) 变量的声明类型尽量是抽象类或接口
   3) 继承时应该遵循里氏替换原则
4. 里氏替换原则
   在使用继承时，在子类中尽量不要重写父类方法
   继承实际上增加了两个类之间的耦合性，可以通过**聚合、组合、依赖**等方法来替换继承来解决问题
5. 开闭原则
   1) 一个软件实体，如类、模块或函数，应该对扩展开放（提供方），对修改关闭（使用方）。用抽象构建框架，用实现扩展细节
   2) 当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过**修改**已有的代码来实现变化
   3) 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则
6. 迪米特法则
   1) 一个对象应该对其他对象保持最少的了解
   2) 类与类关系越密切，耦合度越大
   3) 迪米特法则又叫**最少知道原则**，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，除了提
   供的public方法，不对外泄露任何信息。
   4) 只与直接的朋友进行通信
      **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，那么就说这两个对象是朋友关系。**耦合**的方式很多：依赖、关联、组
      合、聚合等。其中，我们称出现在成员变量、方法参数、方法返回值中的对象为直接的朋友。而出现在局部变量的对象就不是直接朋友。也就是说，**陌生的类**
      **最好不要以局部变量的形式出现在类的内部**。
7. 合成复用原则
   尽量使用合成/聚合的方式，而不是使用继承

### Head First 设计模式中提出的设计原则

* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
* 针对接口编程，而不是针对实现编程
* 多用组合，少用继承
* 为了交互对象之间的松耦合设计而努力
* 开闭原则：类应该对扩展开放，对修改关闭。也就是说，让类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性，可以应对改变，可以接
      受新的功能来应对改变的需求。**不必使代码的每个部分都采用开闭原则**，这会增加代码的复杂度，只需在最有可能改变的地方运用即可。
* 依赖倒置原则：**要依赖抽象，不要依赖具体类**。不能让高层组件依赖底层组件，而且，不管高层或底层组件，“两者”都应该依赖于抽象。所谓“高层”组件是由其他
      低层组件定义其行为的类。比如，PizzaStore属于高层组件，Pizza属于低层组件。**倒置**指的是和一般OO设计的思考方式完全相反。
* 最少知识原则：只和“密友”谈话。也就是减少对象之间的交互，只留下几个“密友”。[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/21)
      就任何对象而言，在该对象的**方法内**，我们只应该调用属于以下范围的方法：
     * 该对象本身
       * 被当做方法的参数而传递进来的对象
         * 此方法所创建或实例化的任何对象
         * 对象的任何组件
* 好莱坞原则：别调用我们，我们会调用你
      好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖底层组件，而底层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依
      赖低层组件时，依赖腐败就发生了。
      在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些底层组件。换句话说，高层组件对待底层组件的
      方式就是**别调用我们，我们会调用你**
* 单一责任原则：一个类应该只有一个引起变化的原因。在实际编码中，区分设计中的责任非常困难。我们应该尽量让每个类保持单一责任（或高内聚）。
      **内聚**用来度量一个类或模块紧密地达到单一目的或责任。当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当
      被设计成支持一组不相关的功能时，我们说它具有低内聚。

## 三、策略模式

**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

在设计类时，我们需要将类中变化的行为独立出来，设计描述该行为的接口，让各种不同的具体行为来实现接口。而在初始类中用“组合”的方式来使用这些具体的行为。

![image-20200327111800261](F:\Java书和视频\笔记\images\设计模式\8.png)

在上述的类图中，Duck类是基类，我们将其中的fly（飞行）和quack（叫声）属性独立出来，设计了FlyBehavior和QuackBehavior接口，让具体的飞行类和叫声类来实
现这个接口，描述各自不同的行为。然后在Duck类中添加FlyBehavior和QuackBehavior的对象来使用和两个行为。

## 四、观察者模式

### 定义

观察者模式定义了对象之间的**一对多依赖**，这样一来，当一个对象改变状态时，它的**所有依赖者**都会收到通知并自动更新

![image-20200327112222766](F:\Java书和视频\笔记\images\设计模式\9.png)

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。**在Swing中就用到了观察者模**

一个使用观察者模式的例子：
   有一个WeatherData对象来观测气象数据，有多个公告板需要使用WeatherData对象观测的数据来展示这些数据，而且数据更新时公告板能够立即得到通知并更新自己
   展示的数据。[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/16)

我们也可以使用java.util包中的Observable类和Observer接口来实现观察者模式，被观察者（主题）继承Observable类，观察者实现Observer接口。但是，因为
Observable是一个类，必须设计一个类继承它。如果某类相同时具有Observable类和另一个超类的行为，那就不可行。

* 观察者模式遵循的设计原则：

  * 找出程序中会变化的方面，然后将其和固定不变的方面分离

    在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，可以改变依赖于主题状态的对象，却不必改变主题。

  * 针对接口编程，不针对实现编程

    主题与观察者都使用接口，观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的有点。

  * 多用组合，少用继承

    观察者模式利用“组合”将许多观察者组合进主题中，对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。

## 五、装饰者模式

### 定义

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

* 装饰者和被装饰对象有相同的超类型
* 可以用一个或多个装饰者包装一个对象
* 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用各种装饰者来装饰对象
  ![image-20200327112910614](F:\Java书和视频\笔记\images\设计模式\10.png)

图中，ConcreteComponent继承Component抽象类是为了有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。且图中的
抽象类Component和Decorator在自己实现的时候都可以改写为接口（interface）。[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/17)

## 六、工厂模式

### 工厂方法

工厂方法用来处理对象的创建，并将这样的行为封装在子类中（在子类中来具体实现创建对象的行为）。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了
![image-20200327140429802](F:\Java书和视频\笔记\images\设计模式\11.png)
![image-20200327140500845](F:\Java书和视频\笔记\images\设计模式\12.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/18)

### 认识工厂方法模式

偶有工厂模式都用来封装对象的创建。工厂方法模式通过让**子类决定**该创建的对象是什么，来达到将对象创建的过程封装的目的。
![image-20200327140523346](F:\Java书和视频\笔记\images\设计模式\13.png)
![image-20200327140542262](F:\Java书和视频\笔记\images\设计模式\14.png)

### 定义工厂方法模式

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。**工厂方法让类把实例化推迟到子类**。
![image-20200327140607002](F:\Java书和视频\笔记\images\设计模式\15.png)

定义中所说的“决定”，并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了
实际创建的产品是什么。

将创建对象的代码集中在一个对象或方法中，可以避免代码中的重复，并且更方便以后的维护。

在工厂模式中使用到了依赖倒置原则。在我们平时设计类时，应该遵循下面几条方针，避免违反依赖倒置原则：

   * 变量不可以持有具体类的引用

   如果使用new，就会持有具体类的引用。可以使用工厂来避免这样的做法

   * 不要让类派生自具体类

   如果派生自具体类，就会依赖具体类。应该派生自一个接口或抽象类

   * 不要覆盖基类中已经实现的方法

   如果覆盖基类已实现的方法，那么基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类

抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要关心实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。
![image-20200327140651839](F:\Java书和视频\笔记\images\设计模式\16.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/18)

### 比较工厂方法和抽象工厂

![image-20200327140727944](F:\Java书和视频\笔记\images\设计模式\17.png)
![image-20200327140758614](F:\Java书和视频\笔记\images\设计模式\18.png)

## 七、单件模式

单件模式确保一个类只有一个实例，并提供一个全局访问点。
![image-20200327140829412](F:\Java书和视频\笔记\images\设计模式\19.png)

### 经典的单件模式代码（饿汉式）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

上述代码中存在问题，即当使用多线程时，也可能会创建出多个对象。（不推荐）

#### 改进的方法

1. 把getInstance()编程同步方法（synchronized）

   只有在第一次执行此方法时才需要同步。所以，设置好instance变量过后，之后每次调用这个方法，同步都是多余的，效率不高。

2. 使用“急切”创建实例，而不用延迟实例化的方法。推荐使用

```java
public class Singleton {
   private static final Singleton instance = new Singleton();
   private Singleton() {}
   public static Singleton getInstance() {
      return instance;
   }
}
```

3. 用“双重检查加锁”，在getInstance()中减少使用同步。推荐使用

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

4. 用类加载模式（静态内部类）推荐使用

```java
public class Singleton {
    private Singleton() {}
	public static class InstanceHolder {
        public static Singleton singleton = new Singleton();
    }
    public static Singleton getSingleton() {
        return InstanceHolder.singleton;// 这里将导致InstanceHolder类被初始化
    }
}
```

5. 枚举方式

```java
public class Singleton {
    public static void main(String[] args) {
        Single single = Single.SINGLE;
        single.print();
    }

    enum Single {
        SINGLE;

        private Single() {
        }

        public void print() {
            System.out.println("hello world");
        }
    }
}
```



## 八、命令模式

命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持**可撤销**的操作。

一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。
![image-20200327141004917](F:\Java书和视频\笔记\images\设计模式\20.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/19)

## 九、适配器模式和外观模式

### 适配器模式

适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
**对象适配器**
![image-20200327141108655](F:\Java书和视频\笔记\images\设计模式\21.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/20)
**类适配器**
类适配器需要通过多重继承来实现，这在Java中不可能。
![ ](F:\Java书和视频\笔记\images\设计模式\22.png)

### 外观模式

**使用到最少知识原则**

外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

外观模式简化接口，也将客户从组件的子系统中解耦。

外观模式和适配器模式都可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口。

## 十、模板方法模式

**模板方法**：定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现

模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

**使用到好莱坞原则**

![image-20200327141216362](F:\Java书和视频\笔记\images\设计模式\23.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/22)

## 十一、迭代器和组合模式

### 迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。（可使用Java自带的Iterator接口）
![image-20200327141239551](F:\Java书和视频\笔记\images\设计模式\24.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/23)
迭代器意味着没有次序。只是取出所有的元素，并不表示取出元素的先后就代表元素的大小次序。

### 组合模式

组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以**一致的方式**处理个别对象以及对象组合。
![image-20200327141305615](F:\Java书和视频\笔记\images\设计模式\25.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/23)

## 十二、状态模式

**定义**：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
定义中的第一部分是说：将状态封装成独立的类，并将动作委托到代表当前状态的对象，行为随着内部状态而改变。
第二部分是说：从客户的视角来看，如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。

![image-20200327141329796](F:\Java书和视频\笔记\images\设计模式\26.png)

[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/24)

### 状态模式与策略模式的区别

对于状态模式，我们将一群行为封装在状态对象中，context的行为随时可委托到哪些状态对象中的一个。当前状态在状态对象集合中游走改变，以反映出context内部的
状态，因此，context的行为也会跟着改变。但是context的客户对于状态对象了解不多，甚至根本是浑然不觉

对于策略模式，客户通常主动指定context所要组合的策略对象是哪一个。对于某个context对象来说，通常都只又一个最适当的策略对象。

## 十三、代理模式

代理模式主要可分为远程代理、虚拟代理和保护代理

### 远程代理

远程代理就好比“远程对象的本地代表”。所谓“远程对象”是一种对象，活在不同的Java虚拟机堆中（在不同的地址空间运行的远程对象）。所谓“本地代表”是一种可以由
本地方法调用的对象，其行为会转发到远程对象中。

客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆中“代理”对象上的方法，再由代理处理所有网络通信的底层细节。

### Java RMI（远程方法调用）

![image-20200327141355743](F:\Java书和视频\笔记\images\设计模式\27.png)
在客户端：客户调用客户辅助对象上的方法，仿佛客户辅助对象就是真正的服务。客户辅助对象再负责为我们转发这些请求。

在服务器端：服务辅助对象从客户辅助对象中接受请求（透过Socket连接），将调用的信息解包，然后调用真正服务对象上的真正方法。所以，对于服务对象来说，调用
是本地的，来自服务辅助对象，而不是远程客户。

RMI提供了客户辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法。RMI的好处在于不必亲自写任何网络或I/O代码。客户程序调用远程方法就和在运行
客户自己的本地JVM上对对象进行正常方法调用一样。

**RMI将客户辅助对象成为Stub（桩），服务辅助对象成为skeleton（骨架）**

#### 制作远程服务

制作远程服务的五个步骤的概要（这些步骤将一个普通的对象变成可以被远程客户调用的远程对象）：

1. **制作远程接口**

远程接口定义出可以让客户远程调用的方法。客户将用它作为服务的类类型。Stub和实际的服务都实现此接口

2. **制作远程的实现**

这是做实际工作的类，为远程接口中定义的远程方法提供了真正的实现。这就是客户真正想要调用方法的对象

3. **利用rmic产生stub和skeleton**

这就是客户和服务的辅助类。不需要自己创建这些类，甚至连生成它们的代码都不用看，因为当运行rmic工具时，这都会自动处理

4. **启动RMI registry（rmiregistry）**

rmiregistry就像是电话簿，客户可以从中查到代理的位置（也就是客户的stub helper对象）

5. **开启远程服务**

让服务对象开始运行。服务实现类会实例化一个服务的实例，并将这个服务注册到RMI registry。注册之后，这个服务就可以供客户调用了

### 代理模式的定义

代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、
创建开销大的对象或需要安全控制的对象。

### 动态代理

![image-20200327141419502](F:\Java书和视频\笔记\images\设计模式\28.png)

Java已经创建李Proxy类，所以需要有办法来告诉Proxy类你要做什么。不能像以前一样把代码放在Proxy类中，而是放在InvocationHandler中。InvocationHandler
的工作是响应代理的任何调用。可以把InvocationHandler想成是代理收到方法调用后，请求做实际工作的对象。