[TOC]



## 计算表达式（将表达式转为后缀表达式，然后计算后缀表达式）

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String expression = in.nextLine();

        List<String> list = new ArrayList();
        boolean flag = false;
        String numVal = "";
        for (int i = 0; i < expression.length(); i++) {
            if (Character.isDigit(expression.charAt(i)) && !flag) {
                flag = true;
                numVal += expression.charAt(i);
            } else if (!Character.isDigit(expression.charAt(i)) && flag) {
                flag = false;
                list.add(numVal);
                numVal = "";
                list.add(String.valueOf(expression.charAt(i)));
            } else if (Character.isDigit(expression.charAt(i)) && flag){
                numVal += expression.charAt(i);
            } else {
                list.add(String.valueOf(expression.charAt(i)));
            }
        }
        if (numVal.length() != 0)
            list.add(numVal);
        List<String> postExp = getPostExp(list);
        String result = calPostExp(postExp);
        
        System.out.println(result);
    }
    
    public static String calPostExp(List<String> postExp) {
        LinkedList<String> stack = new LinkedList<>();
        
        for (String str : postExp) {
            if (str.matches("[]0-9]+")) {//如果遇到了数字，直接入栈
                stack.push(str);
            } else {//如果是运算符，出栈两次，做计算，将结果入栈
                stack.push(doOperation(str, stack.pop(), stack.pop()));
            }
        }
        String ret = stack.pop();
        String[] strings = ret.split("[.]");
        if (strings[1].equals("0"))
            return strings[0];
        else return ret;
    }
    
    public static List<String> getPostExp(List<String> list) {
        LinkedList<String> stack = new LinkedList<>();
        List<String> postExp = new ArrayList<>();
        for (String str : list) {
            if (str.matches("[0-9]+")) {//如果是数，则直接写进表达式
                postExp.add(str);
            } else if(str.equals("*") || str.equals("/")) {//如果是乘或除，入栈
                stack.push(str);
            } else if(str.equals("(")) {//如果是左括号，直接入栈
                stack.push(str);
            } else if(str.equals("+") || str.equals("-")) {//如果是加或减，则遍历栈顶，一直出栈入到表达式，知道遇见了左括号，左括号不出栈
                while (!stack.isEmpty() && !stack.peek().equals("(")) {
                    postExp.add(stack.pop());
                }
                stack.push(str);
            } else if (str.equals(")")) {//如果是右括号，遍历栈顶，一直出栈，直到遇到了左括号，左括号也要出栈。括号不写入表达式
                while (!stack.peek().equals("(")) {
                    postExp.add(stack.pop());
                }
                stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            postExp.add(stack.pop());
        }
        
        
        return postExp;
    }
    

    public static String doOperation(String op, String v1, String v2) {
        Double val1 = Double.valueOf(v1);
        Double val2 = Double.valueOf(v2);

        double res = 0;
        switch(op) {
            case "+" :
                res = (val2 + val1);break;
            case "-" :
                res = (val2 - val1);break;
            case "*" :
                res = (val2 * val1);break;
            case "/" :
                res = (val2 / val1);break;
        }
        return String.valueOf(res);
    }
}
```



## Floyd判圈法（环检测）

此算法可以用来判断链表中是否有环，如果有环能找到环的起点。

**主要思想**

以跑步为例，在一条赛道上两个人同时出发，如果赛道上有圈，那么快的人一定能追上慢的人，而且当两人在相遇时，跑得快的人比慢的人多跑一圈距离的整数倍。在算法中也可以是使用两个指针分别作为slow和fast，fast前进的速度是slow前进速度的两倍。如果两者在**出发点之外**的某一点相遇，那么说明链表有环，否则如果fast到达了链表的结尾，则说明没环。

在相遇过后，**将fast放至链表开始处**，然后让fast和slow的前进速度相同，**当它们再次相遇时，相遇的地方则为环开始的地方**

**解释**

假设起点到环的距离为m，环的周长为n，第一次相遇点距离环起点的距离是k，那么，当fast和slow相遇时，slow的移动距离为`i=m+a*n+k`，因为fast的速度是slow的两倍，那么fast的移动距离为`2i=m+b*n+k`。其中a和b分别为slow和fast在第一次相遇时转的圈数。那么，`i=(b-a)*n`，即**i是圈周长的倍数**。

将fast移到链表起点，而slow位置不变（**距离链表起点位置为i**）后，两者**同时同速**移动，当fast移动m距离到达环的起点后，**slow移动到距离链表起点i+m的位置**，又因为i为圈周长的倍数，可以理解为slow从链表起点出发，走到环的起点，然后绕环转了几圈，所以slow的位置也必然在环的起点。**即两者相遇点就是环的起点**。

**代码示例**

* 代码1：`LeetCode 287 Find the Duplicate Number` 

  ```java
  /*
  Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 
  Example 1:
  Input: [1,3,4,2,2 ] 
  Output: 2 
  
  Example 2:
  Input: [3,1,3,4,2] 
  Output: 3 
  将数组元素和对应索引看作一个有环的链表， 对于数组 A = [2,6,4,1,3,1,5] 
  index 0, 1, 2, 3, 4, 5, 6 
  value 2, 6, 4, 1, 3, 1, 5
  索引是什么？ 索引是指针的相对位置/偏移量 
  那么value 是什么？ 下一个位置的地址 
  那么这个数组就可以转换为 : 0 - > 2 - > 4 -> 3 -> 1 -> 6 -> 5-> [1- >6-> 5 ->1 链表环] 
  可以看到这就是一个有环的链表 
  */
  public static int findDuplicate(int[] nums) {    
  	int slow = 0; 
      int fast = 0; 
      do {  
      	slow = nums[slow]; 
          fast = nums[nums[fast]];    
      } while (slow != fast);
      fast = 0; 
      while (slow != fast) {
      	slow = nums[slow];
          fast = nums[fast];    
      }    
      return slow; 
  }
  ```

* 代码2：剑指offer——链表中环的入口结点

  ```java
  public class Solution {
      public ListNode EntryNodeOfLoop(ListNode pHead) {
          if (pHead == null || pHead.next == null)
              return null;
          ListNode fast = pHead;
          ListNode slow = pHead;
          do {
              fast = fast.next.next;
              slow = slow.next;
          } while (fast != null && fast != slow);
          if (fast != slow)
              return null;
          else {
              fast = pHead;
              while (fast != slow) {
                  fast = fast.next;
                  slow = slow.next;
              }
          }
          return fast;
      }
  }
  
  ```

  

## 全排序算法

**基本思想**

* 把待排记录分为两个部分：
  1. 第一个记录
  2. 剩下的所有元素
* 所有记录的全排列就是所有可能出现在第一个位置的记录与剩下所有元素的全排列
* 如求[a,b,c]的全排列即求
  1. a,[b,c]的排列
     1. a,b,[c]的全排列——abc
     2. a,c,[b]的全排列——acb
  2. b,[a,c]的全排列
     1. b,a,[c]的全排列——bac
     2. b,c,[a]的全排列——bca
  3. c,[a,b]的全排列
     1. c,a,[b]的全排列——cab
     2. c,b,[a]的全排列——cba

**代码示例**

```java
题目描述
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba

public class Solution {
    ArrayList<String> list = new ArrayList<>();
    public ArrayList<String> Permutation(String str) {
        list = helper(str.toCharArray(), 0, str.length() - 1);
        return list;
    }
    public ArrayList<String> helper(char[] chars, int start, int end) {
        if (start == end)
            list.add(new String(chars));
        for (int i = start; i <= end; i++) {
            swap(chars, i, start);
            helper(chars, start + 1, end);
            swap(chars, i, start);
        }
        
        return set;
    }
    public void swap(char[] chars, int from, int to) {
        char temp = chars[from];
        chars[from] = chars[to];
        chars[to] = temp;
    }
}
```

* helper函数执行真正的全排列算法，接收三个参数，数组chars，起始位置start，终止位置end，意思是**完成chars数组从start到end之间记录的全排列**

* 分为两个步骤

  1. 确定第一位的字符

     数组从start到end的所有记录都可以出现在第一个位置，所以直接一个for循环，考虑了所有情况。在for循环中，swap方法就是交换位置i和位置start的字符，保证当前i指向的记录出现在第一个位置，也就是start指向的位置

  2. 剩下的记录继续做全排列

     这个就是一个递归函数的调用，只需要修改起始位置，也就是改为start+1，因为start的位置已经放了记录，所以只需要继续做从start+1到end的全排列即可

* 紧接着的swap方法的作用：因为数组传递的是地址，所以，所有的修改对所有人都是共享的，因此为了保证每一次的交换不会对下一次的交换产生影响，要重新交换位置，也就是复原，不然对下一次的交换就有影响了。

  **递归的终止条件是当start==end，也就是只有一个记录需要做全排列，也就是最后一个记录，这就是全排列的一种情况，需要保存本次的记录**

## LeetCode 62. Unique Path

A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?



![image-20200331184940149](F:\Java书和视频\笔记\images\算法\1.png)

### 1. 动态规划

到达点(x,y)的路径数=到达(x - 1, y)的路径数+到达(x, y - 1)的路径数，因此可以使用动态规划：

```java
public int uniquePaths_dp(int m, int n) {
        if (m == 0 || n == 0)
            return 1;

        int[][] matrix = new int[n][m];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) matrix[i][j] = 1;
                else 
                    matrix[i][j] += matrix[i - 1][j] + matrix[i][j - 1];
            }
        }
        
        return matrix[n - 1][m - 1];

    }
```

### 2. 优化的动态规划

对于起点到(i,j)的路径总数matrix[j] =起点到(i - 1, j)的路径总数matrix[j]+起点到(i, j - 1)的路径总数matrix[j - 1]。

```java
public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0)
    	return 1;

    int[] matrix = new int[n];

    matrix[0] = 1;
    for (int j = 0; j < m; j++) {
    	for (int i = 1; i < n; i++) {
    		matrix[i] += matrix[i - 1];
    	}
    }

    return matrix[n - 1];
}
```

## BFS Template

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

如果不能对节点重复访问，那么应该再添加一个Set结构

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    Set<Node> visited;  // store all the nodes that we've visited
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to visited;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in visited) {
                    add next to queue;
                    add next to visited;
                }
                remove the first node from queue;   
            }
        }
    }
    return -1;          // there is no path from root to target
}
```

## DFS Recursion Template

```java
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
```

## DFS using an explicit stack

```java
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> stack;
    add root to stack;
    while (s is not empty) {
        Node cur = the top element in stack;
        remove the cur from the stack;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to visited;
                add next to stack;
            }
        }
    }
    return false;
}
```

[二叉树非递归遍历](https://juejin.im/post/59e3fde451882578c20858a5)

**目前可以使用递归来解决的问题**

* DFS
* 树的遍历

## 使用递归来解决二叉树相关问题

用递归来解决二叉树问题有两种方法：

* “Top-down” Solution
* “Bottom-up” Solution

[LeetCode-使用递归解决二叉树问题](https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/534/)

When you meet a tree problem, ask yourself two questions: **Can you determine some parameters to help the node know its answer?** **Can you use these parameters and the value of the node itself to determine what should be the parameters passed to its children?** If the answers are both yes, try to solve this problem using a =="`top-down`"== recursive solution.

```java
//使用top-down来计算二叉树的最大深度
private int answer;		// don't forget to initialize answer before call maximum_depth
//如果我们知道了当前节点的深度，我们就能知道它子节点的深度，将子节点的深度作为参数传给子节点，让它递归执行，直到叶节点
private void maximum_depth(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        answer = Math.max(answer, depth);
    }
    maximum_depth(root.left, depth + 1);
    maximum_depth(root.right, depth + 1);
}
```

Or, you can think of the problem in this way: **for a node in a tree, if you know the answer of its children, can you calculate the answer of that node?** If the answer is yes, solving the problem recursively using a `bottom up` approach might be a good idea.

```java
//使用bottom-up来计算二叉树的最大深度
//如果知道了子树的深度，也就可以选择最大的值加上1作为当前节点的深度，从底向上计算
public int maximum_depth(TreeNode root) {
	if (root == null) {
		return 0;                                   // return 0 for null node
	}
	int left_depth = maximum_depth(root.left);
	int right_depth = maximum_depth(root.right);
	return Math.max(left_depth, right_depth) + 1;	// return depth of the subtree rooted at root
}
```

## 递归

### 递归函数

For a problem, if there exists a recursive solution, we can follow the guidelines below to implement it. 

For instance, we define the problem as the function ${F(X)}$ to implement, where ${X}$ is the input of the function which also defines the scope of the problem.

Then, in the function ${F(X)}$, we will:

1. Break the problem down into smaller scopes, such as ${x_0} \in X, {x_1} \in X, ..., {x_n} \in X$;
2. Call function$ {F(x_0)}, F(x_1), ..., F(x_n)$ **==recursively==** to solve the subproblems of ${X}$;
3. Finally, process the results from the recursive function calls to solve the problem corresponding to ${X}$.

### 递归关系

There are two important things that one needs to figure out before implementing a recursive function:

- `recurrence relation`: the relationship between the result of a problem and the result of its subproblems.
- `base case`: the case where one can compute the answer directly without any further recursion calls. Sometimes, the base cases are also called *bottom cases*, since they are often the cases where the problem has been reduced to the minimal scale, *i.e.* the bottom, if we consider that dividing the problem into subproblems is in a top-down manner.

## 动态规划

DP：“careful brute force”

DP：“guessing + recursion + memoization”(I don’t know the answer, i guess all the possible )

DP： shortest path in some DAG

time = #subproblems * time/subproblem

### 5 “easy” steps to DP

1. define subproblems –> #subproblems 
2. guess (part of solution)
3. relate subproblem solutions(DP formula)
4. recurse & memoize (or build DP table bottom-up)
5. solve the original problem

**How to choose subproblems**

1. suffixes 	$x[i:] ∀i$
2. prefixes    $x[:i]∀i$
3. substrings    $x[i:j] ∀i<=j$

## HashMap

* 使用HashMap的场景：
  1. we `need more information` rather than only the key. Then we can `build a mapping relationship between key and information` by hash map.
  2. aggregate all the information by key. The key to solving this kind of problem is to `decide your strategy when you encounter an existing key`. Sometimes, we might sum all the values up. And sometimes, we might replace the original value with the newest one. The strategy depends on the problem and practice will help you make a right decision.

* Design the key

  In the previous problems, the choice of key is comparatively straightforward. Unfortunately, sometimes you have to think it over to `design a suitable key` when using a hash table.

  Actually, `designing a key` is to `build a mapping relationship by yourself` between the original information and the actual key used by hash map. When you design a key, you need to guarantee that:

  > \1. All values belong to the same group will be mapped in the same group.
  >
  > \2. Values which needed to be separated into different groups will not be mapped into the same group.

  This process is similar to design a hash function, but here is an essential difference. `A hash function satisfies the first rule but might not satisfy the second one.` But your mapping function should satisfy both of them.

* ==Here are some takeaways about how to design the key for you.==

  1. When the order of each element in the string/array doesn't matter, you can use the `sorted string/array` as the key.![img](F:\Java书和视频\笔记\算法\1.png)
  2. If you only care about the offset of each value, usually the offset from the first value, you can use the `offset` as the key.![img](F:\Java书和视频\笔记\算法\2.png)
  3. In a tree, you might want to directly use the `TreeNode` as key sometimes. But in most cases, the **==`serialization==** of the subtree` might be a better idea.![img](F:\Java书和视频\笔记\算法\3.png)
  4. In a matrix, you might want to use `the row index` or `the column index` as key.
  5. In a Sudoku, you can combine the row index and the column index to identify which `block` this element belongs to.![img](F:\Java书和视频\笔记\算法\4.png)
  6. Sometimes, in a matrix, you might want to aggregate the values in the same `diagonal line`. ![img](F:\Java书和视频\笔记\算法\5.png)

### kSum

After you solve 4Sum II, an interviewer can follow-up with 5Sum II, 6Sum II, and so on. What they are really expecting is a generalized solution for `k` input arrays. Fortunately, the hashmap approach can be easily extended to handle more than 4 arrays.

Above, we divided 4 arrays into two equal groups, and processed each group independently. Same way, we will divide *k* arrays into two groups. For the first group, we will have $\frac{k}{2}$ nested loops to count sums. Another $\frac{k}{2}$ nested loops will enumerate arrays in the second group and search for complements.

**Algorithm**

We can implement $\frac{k}{2}$ nested loops using a recursion, passing the index `i` of the current list as a parameter. The first group will be processed by `addToHash` recursive function, which accumulates `sum` and terminates when adding the final sum to a hashmap `m`.

The second function, `countComplements`, will process the second group, accumulating the `complement `value. It terminates when searching for the final `complement` value in the hashmap, adding its count to the result.

```java
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
    return kSumCount(new int[][]{A, B, C, D});
}
public int kSumCount(int[][] lists) {
    Map<Integer, Integer> m = new HashMap<>();
    addToHash(lists, m, 0, 0);
    return countComplements(lists, m, lists.length / 2, 0);
}
void addToHash(int[][] lists, Map<Integer, Integer> m, int i, int sum) {
    if (i == lists.length / 2)
        m.put(sum, m.getOrDefault(sum, 0) + 1);
    else
        for (int a : lists[i])
            addToHash(lists, m, i + 1, sum + a);
}
int countComplements(int[][] lists, Map<Integer, Integer> m, int i, int complement) {
    if (i == lists.length)
        return m.getOrDefault(complement, 0);
    int cnt = 0;
    for (int a : lists[i])
        cnt += countComplements(lists, m, i + 1, complement - a);
    return cnt;
}
```

### QuickSelect(通过快排来确定准确的位置)

**Hoare's selection algorithm**

Quickselect is a [textbook algorthm](https://en.wikipedia.org/wiki/Quickselect) typically used to solve the problems "find `k`*th* something": `k`*th* smallest, `k`*th* largest, `k`*th* most frequent, `k`*th* less frequent, etc. Like quicksort, quickselect was developed by [Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare), and also known as *Hoare's selection algorithm*.

It has $\mathcal{O}(N)$average* time complexity and widely used in practice. It worth to note that its worth case time complexity is $\mathcal{O}(N^2)$, although the probability of this worst-case is negligible.

The approach is the same as for quicksort.

> One chooses a pivot and defines its position in a sorted array in a linear time using so-called *partition algorithm*.

## Binary Search

### **Template #1：**

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length - 1;
  while(left <= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```

Template #1 is the most basic and elementary form of Binary Search. It is the standard Binary Search Template that most high schools or universities use when they first teach students computer science. Template #1 is used to search for an element or condition which can be determined by ***accessing a single index* in the array**.

**Key Attributes:**

------

- Most basic and elementary form of Binary Search
- Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)
- No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found

 

**Distinguishing Syntax:**

------

- Initial Condition:` left = 0, right = length-1`
- Termination: `left > right`
- Searching Left: `right = mid-1`
- Searching Right: `left = mid+1`

### **Template #2:**

```java
int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;

  int left = 0, right = nums.length;
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.length && nums[left] == target) return left;
  return -1;
}
```

Template #2 is an advanced form of Binary Search. It is used to search for an element or condition which requires ***accessing the current index and its immediate right neighbor's index* in the array**.

**Key Attributes:**

------

- An advanced way to implement Binary Search.
- Search Condition needs to access element's immediate right neighbor
- Use element's right neighbor to determine if condition is met and decide whether to go left or right
- Gurantees Search Space is at least 2 in size at each step
- Post-processing required. Loop/Recursion ends when you have 1 element left. Need to assess if the remaining element meets the condition.

 

**Distinguishing Syntax:**

------

- Initial Condition: `left = 0, right = length`
- Termination: `left == right`
- Searching Left: `right = mid`
- Searching Right: `left = mid+1`

### **Template #3:**

```java
int binarySearch(int[] nums, int target) {
    if (nums == null || nums.length == 0)
        return -1;

    int left = 0, right = nums.length - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

**Key Attributes:**

------

- An alternative way to implement Binary Search
- Search Condition needs to access element's immediate left and right neighbors
- Use element's neighbors to determine if condition is met and decide whether to go left or right
- Gurantees Search Space is at least 3 in size at each step
- Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.

 

**Distinguishing Syntax:**

------

- Initial Condition:` left = 0, right = length-1`
- Termination: `left + 1 == right`
- Searching Left: `right = mid`
- Searching Right: `left = mid`