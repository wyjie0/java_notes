

# 一、运行时数据区

## 1、运行时数据区

![image-20200422141818681](F:\Java书和视频\笔记\images\jvm\1.png)

### 1.1 pc寄存器

Java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的pc寄存器（线程私有的）（program counter）。在任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的**当前方法**。如果这个方法不是native的，那pc寄存器就保存java虚拟机**正在执行的字节码指令的地址**；如果该方法是native的，那pc寄存器的值是undefined。

可以把它看做当前线程所执行字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

### 1.2 Java虚拟机栈

每一条Java虚拟机线程都有自己私有的Java虚拟机栈，这个栈与线程同时创建，用于存储**栈帧**。

Java虚拟机栈的作用是：存储**局部变量**和一些**尚未算好的值**。

因为除了栈帧的出栈和入栈之外，Java虚拟机栈不糊再受到其他因素的影响，所以栈帧可以在堆中分配，Java虚拟机栈所使用的的内存不需要保证是连续的。

Java虚拟机栈可能发生如下异常情况：

* 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将抛出一个`StackOverflowError`异常
* 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建新的虚拟机栈，那Java虚拟机栈将会抛出`OutOfMemoryError`异常

**`StackOverflowError`和`OutOfMemoryError`的区别**

`StackOverflowError`：栈溢出错误。如果一个线程在计算时所需要用到栈大小$>$配置允许最大的栈大小，那么Java虚拟机将抛出这个异常。（在创建好，使用时。内存可能还够，只是超出了规定的大小）

`OutOfMemoryError`：内存溢出。（这个在创建或扩展栈时，由于内存大小不够了）

### 1.3 Java堆

堆是可供各个**线程共享的内存区域**，也是供所有**类实例和数组对象分配内存的区域**。

Java堆**在虚拟机启动的时候被创建**，它存储了被垃圾收集器所管理的所有对象，这些受管理的对象无需也无法显示地销毁。

Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间的时候自行收缩。Java堆所使用的**内存也不需要是连续的**。

Java堆可能出现的异常情况：

如果实际所需的堆超过了自动内存管理系统（垃圾收集器）能提供的最大容量，Java虚拟机会抛出`OutOfMemoryError`异常

### 1.4 方法区

方法区是线程共享的运行时内存区域，它存储了每一个类的结构信息，例如：**运行时常量池**、**字段和方法数据**、**构造函数**和**普通方法的字节码内容**，还包括一些在类、实例、接口初始化时用到的特殊方法。

方法区**在虚拟机启动的时候创建**，它是**堆的逻辑组成部分**，也就是说它使用的内存就是堆内存。

方法区可能发生如下异常情况：

* 如果方法区的内存空间不能满足内存分配请求，那么Java虚拟机将抛出一个`OutOfMemoryError`异常

### 1.5 运行时常量池

运行时常量池是class文件中每一个类或接口的**常量池表**的运行时表示形式，它包括了若干种不同的常量。包括：**从编译期可知的数值字面量**到**必须在运行期解析后才能获得的方法或字段引用**。在Class文件中除了有类的版本、字段、方法、接口等描述信息以外，还有一项信息就是常量池表，用于存放**编译期**生成的各种字面量与符号引用。而常量池表的内容就用于填充运行时常量池

每一个运行时常量池都在Java虚拟机的方法区中分配，在**加载类和接口到虚拟机后**，就创建对应的运行时常量池。

在创建类和接口的运行时常量池时，如果构造运行常量池所需要的内存空间超过了方法区所能提供的最大值，那么Java虚拟机就会抛出一个`OutOfMemoryError`异常。

### 1.6 本地方法栈

Java虚拟机实现如果用到传统的栈来支持native方法，这个栈就是本地方法栈。

## ==2、栈帧==

栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值和异常分派。

栈帧随着**方法调用**而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。栈帧的存储空间由创建它的线程分配在Java虚拟机栈中，每一个栈帧都有自己的**本地变量表**、**操作数栈**和**指向当前方法所属的类的运行时常量池的引用**

在某天线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的，这个栈帧称为**当前栈帧**，这个栈帧对应的方法称为**当前方法**，定义这个方法的类称作**当前类**。

栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一个线程的栈帧。

![image-20200425090611017](F:\Java书和视频\笔记\images\jvm\10.png)

### 2.1 局部变量表

每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译器决定。==Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用类方法时，它的参数将会依次传递到局部变量表中从0开始的连续位置上。当调用实例方法时，第0个局部变量一定用来存储该实例方法所在对象的引用，后续的其他参数将会传递至局部变量表从1开始的连续位置上==  

### 2.2 操作数栈

每个栈帧都包含一个称为操作数栈的栈。栈帧在刚刚创建时，操作数栈时空的，Java虚拟机提供一些字节码指令来从**局部变量表**或**对象实例**的字段中复制常量或变量值到操作数栈中，也提供一些指令用于从操作数栈中取走数据、操作数据以及把操作结果重新入栈。

### 2.3 动态链接

每个栈帧内部都包含一个指向当前方法所在类型的**运行时常量池**的引用，以便对当前方法的代码实现动态链接。

在class文件里面，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，动态链接的作用就是将这些以符号引用所表示的方法转换成对实际方法的直接引用。==因为在运行时常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转换为直接引用，这种转换称为**静态解析**。另外一部分在每一次运行期间转换为直接引用，这部分称为**动态链接**。==

### 2.4 方法调用正常完成

方法调用的正常完成是指在方法的执行过程中，没有抛出任何异常——包括直接从Java虚拟机中抛出的异常以及在执行时通过throw语句显示抛出的异常。

在这种场景下，当前栈帧会恢复调用者的状态，包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器，以跳过刚才执行的方法调用命令等。调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行

## 3、特殊方法

在Java虚拟机的层面上，类的构造器是一个一个叫做<init>的特殊==**实例化初始方法**==的形式出现的。实例初始化方法只能在实例的初始化期间，通过Java虚拟机的`invokespecial`指令来调用，而且只能在尚未初始化的对象上调用该指令。构造器的权限访问，也会约束由该构造器所衍生出来的实例初始化方法。

一个类或接口最多可以包含不超过一个**==类或接口的初始化方法==**， 类或接口就是通过这个方法来完成初始化的。这个方法是一个不包含参数、返回类型为void的方法，名为<clinil>。类或接口的初始化方法由Java虚拟机自身隐式调用，没有任何虚拟机字节码可以调用这个方法，它只会在**类的初始化阶段中由虚拟机自身调用**。

## 4、异常

抛异常的本质实际上是程序控制权的一种即时的、非局部的转换——从抛出异常的地方转换至异常处理的地方。

Java虚拟机中异常的出现总是由下面三种原因之一导致的：

1. `athrow`字节码指令被执行
2. 虚拟机同步检测到程序发生了非正常的执行情况，这时异常必将紧接着在发生非正常执行情况的字节码指令之后抛出，而不会在执行程序的过程中随时抛出
3. 由于以下原因导致了异步异常的出现：
   * 调用了Thread或者ThreadGroup的stop方法
   * Java虚拟机实现发生了内部错误

## 5、方法调用指令

* `invokevirtual`指令用于调用对象的**实例方法**，根据对象的实际类型进行分派
* `invokeinterface`指令用于调用**接口方法**，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用
* `invokespecial`指令用于调用一些需要特殊处理的**实例方法**，包括实例初始化方法、私有方法和父类方法
* `invokestatic`指令用于调用命名类中的**类方法**
* `invokedynamic`指令用于调用以绑定了`invokedynamic`指令的调用点对象作为目标的方法。调用点对象是一个特殊的语法结构，当一条`invokedynamic`指令首次被Java虚拟机执行前，Java虚拟机将会执行一个引导方法，并以这个方法的运行结果作为调用点对象。

## ==6、HotSpot虚拟机对象探秘==

### 6.1 对象的创建

当Java虚拟机遇到一条字节码new指令时，**首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用**，并且检查**这个符号引用代表的类是否已被加载、解析、初始化过，如果没有，那么必须先执行相应的类加载过程**。

类加载检查通过后，虚拟机开始为新生对象分配内存，所需内存大小在类加载完成后便可完全确定，为对象分配空间的过程实际上就是从Java堆中划分出一个确定大小的内存块（**此时的对象还没有进行实例化，只是完成了类的加载-验证-准备-解析-初始化阶段**）。如何划分内存由垃圾收集器来确定。

对象内存分配完成过后，**虚拟机必须将分配到的内存空间都初始化为零值**，这步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，是程序能够访问到这些字段的数据类型所对应的零值。

接下来，虚拟机对对象进行必要的设置，也就是填充其**对象头**，包括：这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

**接下来虚拟机要对新创建的对象进行初始化——构造函数**，即执行Class文件中的<init>方法（这个时候才执行对象的实例化过程）。在new指令之后会接着执行<init>方法，按照程序员的意向对对象进行初始化，这样一个真正的对象才算完全被构造出来。

整个过程简要描述：

1. new 指令找到运行时常量池中的符号引用
2. 检查符号引用代表的类是否已经完成过类加载的过程
3. 没有加载的话，先进行类加载，在这个时候能够确定对象所需的内存空间大小
4. 为新对象在堆中开辟一个内存空间，并初始零值，这时有了一个新生对象，里面的值全是初始值
5. 开始填充这个对象的内容。首先填充的是对象头
6. 按构造方法填充对象

经过上述六步，一个对象就被完全构造出来了。我们可以看到，类加载和对象实例化完全是两个东西，不要混淆了。

### 6.2 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。

对象头部分包括两类信息，第一类是对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

### 6.3 对象的访问定位

**Java程序通过栈上的reference数据来操作堆上的具体对象**。主流的访问方式主要有使用句柄和直接指针两种：

* 使用句柄：Java堆中可能会划分出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象示例数据与类型数据各自具体的地址信息，

![image-20200422150645617](F:\Java书和视频\笔记\images\jvm\2.png)

* 使用直接指针：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址

![image-20200422150830276](F:\Java书和视频\笔记\images\jvm\3.png)

# ==二、内存分配策略和垃圾收集器==

## 1、内存分配策略

Java中的对象都分配在堆中，大小可用-Xms（初始堆的大小，也可看做分配堆的最小内存）和-Xmx（最大堆的大小）来控制。**整个堆**又被划分成了**新生代**和**老年代**（主要为了用于垃圾回收）。新生代又进一步划分为Eden区和Survivor区。新生代大小由-Xmn来控制。

对象首先分配在新生代的Eden区。每次使用Eden区和一个survivor区，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC，存活的对象被复制进另一个Survivor区（复制算法）。当survivor区的空间不够时，需要依赖老年代进行分配担保。

大对象直接进入老年代。所谓的大对象是指，需要大量连续内存空间的对象，比如很长的字符串或数组。

长期存活的对象会进入老年代，比如在新生代中存活了15次的对象（默认为15，也就是经历了15此MinorGC依然存活的对象）

## 2、哪些内存需要回收

当内存不够用的时候，就需要进行垃圾回收（当然也可以手动指定何时进行垃圾回收）。在堆里存放着Java中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要**确定这些对象之中有哪些还存活着，有哪些已经死去（不可能再被任何途径使用的对象）。这些已死对象的内存就是需要回收的内存**

### 2.1 如何判断对象“已死”

#### 1. 引用计数法

在对象中添加一个引用计数器，任何时候，如果有一个地方引用它，那么引用计数器就加1；当引用失效后，引用计数器减1，任何时刻计数器为零的对象就是不能再被使用的对象了。

优点：1. 可立即垃圾回收，每个对象都直到自己的引用计数，当变为0时可以立即回收，将自己接到空闲链表；2. 不需要沿指针查找。

缺点：但是单独的引用计数很难解决对象之间相互循环引用的问题。如果两个对象互相引用，但是这两个对象都不会再被使用到，它们不会被当作“死对象”。而且，计数器会占用额外的内存空间。

主流的Java虚拟机并没有采用这种方式来判断对象是否不可用。

#### 2. 可达性分析算法

通过一系列称为GC Roots的跟对象作为起始节点集，从这些对象开始，根据引用关系向下搜索，搜索过程所走过的路径称为**引用链**，如果某个对象到GC Roots间没有任何引用链相连，则这个对象是不能再被使用的。

![image-20200423090201259](F:\Java书和视频\笔记\images\jvm\4.png)

**GC Roots从哪儿选择呢？**

在Java中， 固定可作为GC Roots的对象包括以下几种：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等（因为这些对象已经被引用，所以肯定是活对象。也就是说，可以以任意活对象作为GC root）
* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
* 在方法区中常量引用的对象，比如Java字符串常量池里的引用
* 在本地方法中JNI（Native方法）引用 的对象
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（`NullPointerException`、`OutOfMemoryError`)等，还有系统类加载器
* 所有被同步锁持有的对象
* 反应Java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等

### 2.2 方法区的垃圾回收

方法区的垃圾回收主要分为两部分：废弃的常量和不再使用的类型。

判定一个常量是否需要回收和判定对象的方法一样，但是**判定一个类型是否属于“不再被使用”的条件需要同时满足下列三个条件：**

* 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
* 加载该类的类加载器已经被回收，这个条件很难达成
* 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 3、什么时候回收

### 3.1 ”引用“的含义

Java将引用分为**强引用**，**软引用**，**弱引用**，**虚引用**。这4中引用强度依次主键减弱。

* 强引用：最传统的引用方式，指在程序代码之中皮鞭存在的引用赋值，类似于`Object obj = new Object()`这种引用关系。**无论任何情况下， 只要强引用关系还存在，垃圾回收器就不会回收掉被引用的对象。**
* 软引用：描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统要发生内存溢出之前，会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。也就是说，第一次进行垃圾回收时，不会回收软引用对象，但是会将它们标记，可看作撤销软引用。（比弱引用多一次存活的机会）`SoftReference`类用于实现软引用
* 弱引用：描述那些非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，**无论当前内存是否足够，都会回收掉被弱引用关联的对象**。`WeakReference`类用于实现弱引用
* 虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用，一个对象是否有虚引用存在，完全不会对其生存时间产生影响，也无法通过虚引用来取得一个对象的实例。**为一个对象设置虚引用的目的是为了能在这个对象被收集器回收时得到一个系统通知**。`PhantomReference`类用于实现虚引用

### 3.2 什么时候对象才会真正的“死去”

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”，要真正说一个对象死亡，至少需要经历**两次标记过程**：

1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；随后进行一次筛选，==检查此对象是否有必要执行`finalize()`方法，假如对象**没有覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过**，那么虚拟机将这两种情况都视为没有必要执行==**

2. 如果被判定为有必要执行，那么会将该对象加入一个队列， 虚拟机会创建一个线程去执行这个对象的`finalize()`方法，但是不会等待这个方法执行结束（比如这个方法执行太慢，或发生了死循环），在此时，如果该对象想要自己继续存活，那么它只有在`finalize()`方法中重新与引用链上的任何一个对象建立关联，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量；如果这个对象在`finalize()`方法中没有逃脱，那此时才会被真正的回收。

**一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临想一次被回收，它的`finalize()`方法就不会被在此执行。==`finalize()`方法不建议使用==**

## 4、怎么回收——垃圾收集算法

### 4.1 分代收集理论

两个分代假说：

1. 弱分代假说：绝大多数对象都是朝生夕死
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡

这样就产生了一种思想，将Java堆分成不同的区域，然后将回收对象依据其年龄分配到不同的区域中去。把大多数对象集中在一起，每次回收只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价会受到大量的内存。把剩下少量的难以消亡的对象存放到一起，虚拟机可以是用较低频率来回收这个区域。

**针对不同分代的垃圾收集名词**

* 部分收集（`Partial GC`）：指不是完整收集整个Java堆的垃圾收集，其中又分为：
  * 新生代收集（`Minor GC/Young GC`）：指目标**只是新生代**的垃圾收集
  * 老年代收集（`Major GC/Old GC`）：指目标**只是老年代**的垃圾收集。目前只有**CMS收集器**会有单独收集老年代的行为。
  * 混合收集（`Mixed GC`）：指目标是收集**整个新生代**以及**部分老年代**的垃圾收集

* **整堆收集（`Full GC`）**：收集**整个Java堆**和**方法区**的垃圾收集

### 4.2 标记-清除算法

算法分为“标记”和“清除”两个阶段：**首先标记出所有需要回收的对象（根据可达性分析，从GC roots开始扫描堆存活的对象进行标记），在标记完成之后，统一回收掉所有被标记的对象。**

缺点：

1. **执行效率不稳定**，如果Java堆中包含大量的对象，而且其中大部分是需要回收的，这时必须进行大量标记和清除动作，导致标记和清除两个过程的执行效率都会随对象数量增长而降低
2. 内存空间的**碎片化问题**，标记-清除会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集操作

![image-20200423100329528](F:\Java书和视频\笔记\images\jvm\5.png)

### 4.3 标记-复制算法

最开始是将可用内存划分为**大小相等的两块**，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把用过的内存空间一次清理掉。这种方式实现简单，运行高效，但是将可用内存缩减到了原来的一半。

![image-20200423100656399](F:\Java书和视频\笔记\images\jvm\6.png)

很多虚拟机采用这种垃圾收集算法来回收**新生代**，但是内存划分不同。具体做法是：==把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存都只是用Eden空间和其中一个Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是$8 ：1$，这样新生代只有10%的内存会被浪费。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（老年代）进行分配担保。==

### 4.4 标记-整理算法

因为老年代中的对象大多存活率都很高，所以不适合使用标记-复制算法。**因为如果存活的对象太多，会进行非常多的复制操作**。老年代的垃圾收集一般使用**标记-整理**算法

在标记了存活对象过后，让所有存活的对象都向内存的一端移动，然后直接清理掉**边界以外的内存**

![image-20200423101629815](F:\Java书和视频\笔记\images\jvm\7.png)

它与标记-清除算法的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；标记-整理算法会将所有活的对象进行移动，并对不存活的对象进行处理，不会产生内存碎片。

## 5、GC的触发条件

- Minor GC触发条件：当新生代空间满了过后，会触发Minor GC
- Full GC触发条件：
    1. 调用System.gc()，系统建议执行full GC
    2. 老年代空间不足
    3. 方法区空间不足
    4. 通过Minor GC进入老年代的平均大小大于老年代的可用内存
    5. 由Eden区和Survivor1区向Survivor2区复制存活对象时，如果Survivor2区的空间不够，则把对象放入老年区，如果此时老年区的可用大小小于要转入的大小，会触发full gc

# 三、类文件的结构

我们已经知道了Java虚拟机中的内存结构，对象如何在内存中存储，方法如何调用。但是这是最底层的知识，我们还需要知道我们编写的源代码时如何编译成字节码文件，然后加载到虚拟机，经过验证、解析等阶段最终生成各种类信息以及对象实例，然后存储到内存中。这一整个过程是后面要说到的。

## 1、Java平台无关性的基石

各种不同平台的虚拟机，以及所有平台都统一支持的程序存储格式——字节码，是构成平台无关性的基石。

Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。

## 2、Class类的文件结构

**注意** 任何一个Class文件都对应着**唯一的一个**类或接口的定义信息，但是反过来，类或接口不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）

class文件的格式要求很严格，有很多固定项。整个Class文件可被看作一张表，这张表的数据项按**严格顺序**排列构成

![image-20200424084621550](F:\Java书和视频\笔记\images\jvm\8.png)

下面来描述每一个部分的含义

### 2.1 魔数与Class文件的版本

每个Class文件的头4个字节被称为魔数，用以**确定这个Class文件是否为一个能被虚拟机接受的文件**。

紧接着魔数的是Java版本号，前两个字节是次版本号，后两个字节是主版本号

### 2.2 常量池

由于常量池中的数据量是不固定的， 因此需要在常量池的入口放置一项u2类型的数据，代表常量池容量计数值，这个值从1开始计数

常量池中主要存放两大类常量：**字面量**和**符号引用**。字面量包括：文本字符串、被声明为final的常量值等。符号引用主要包括下面几类常量：

* 被模块导出或者开放的包
* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符
* 方法句柄和方法类型
* 动态调用点和动态常量

在Class文件中不会保存各种方法、字段最终在内存中的的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机进行类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时**解析、翻译**到具体的内存地址之中。

### 2.3 访问标志

访问标志用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final

### 2.4 类索引、父类索引和接口索引集合

Class文件中由着三项来确定该类型的继承关系，**类索引用于确定这个类的全限定名**，**父类索引用于确定这个类的父类的全限定名**，**接口索引集合就用来描述这个类实现了哪些接口**

### 2.5 字段表集合

字段表用于描述接口或者类中声明的变量，它包括类级变量和实例级变量

### 2.6 方法表集合

方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，==方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放到方法属性表集合中一个名为Code的属性里面==。

==要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求**必须有一个与原方法不同的特征签名**。特征签名是指一个方法中各个**参数**在常量池中的字段符号引用的集合，**返回值不会包含在特征签名中，所以Java里面无法仅仅依靠返回值的不同来对一个已有的方法进行重载**。==

但是在**Class文件格式之中**，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，**如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的**。

# ==四、虚拟机类加载机制==

在了解了Class文件的结构过后，我们进一步就需要关心这些Class文件是如何被加载到JVM中的，还有就是Class文件中的信息进入到虚拟机过后会发生什么样的变化

## 1、概述

Java虚拟机把描述类的信息从Class文件加载到**内存**，并对数据进行**校验**、**转换解析**和**初始化**，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制

## 2、类加载的时机（什么时候开始加载）

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备、解析统称为连接

![image-20200424102158129](F:\Java书和视频\笔记\images\jvm\9.png)

其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而**解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定**。

对于何时需要开始加载并没有进行强制化约束，但是对于**初始化阶段**，==严格规定了有且仅有六种情况必须立即对类进行初始化（在初始化之前会先开始加载、验证和准备）==：

1. 遇到`new、getstatic、putstatic或invokestatic`这四条字节码指令时，如果类型没有进行过初始化，则需要先进行初始化。能够生成这四条指令的典型Java场景有：

   * 使用new关键字实例化对象的时候

   * 读取或设置一个类型的静态字段（**被final修饰、已在编译期把结果放入常量池的静态字段除外**）的时候

   * 调用一个类型的静态方法的时候

     所以，以下情况，类不会被初始化：

     ```java
     public class InitTest {
         //public static String s = "123";这样会初始化
         public final static String s = "123";
         
         static {
             System.out.println("initialized");
         }
     }
     class A{
         public static void main(String[] args) {
             System.out.println(InitTest.s);
         }
     }
     
     //输出：123
     ```

2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有初始化，则需要先触发其初始化

3. **当初始化类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化**

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类

5. 当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

这六个场景中的行为称为对一个类型的主动引用，除此之外，所有引用类型的方式都不会触发初始化，称为被动引用：

被动引用的例子之一：

```java
/**
* 被动使用类字段演示一：
* 通过子类引用父类的静态字段，不会导致子类初始化
**/
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}
public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}
/**
* 非主动使用类字段演示
**/
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```

上述代码执行过后只会输出`SuperClass init!`。==对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。==只与是否触发子类的加载、验证过程则根据具体的虚拟机实现而定。

被动引用的例子之二：

```java
/**
* 被动使用类字段演示二：
* 通过数组定义来引用类，不会触发此类的初始化
**/
public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```

这段代码运行之后没有输出`SuperClass init!`，说明并没有触发类`SuperClass`的初始化

被动引用例子之三：

```java
/**
* 被动使用类字段演示三：
* 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的
类的初始化
**/
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final String HELLOWORLD = "hello world";
}
/**
* 非主动使用类字段演示
**/
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

在编译阶段通过常量传播优化，已经将常量`hello world`直接存储到`NotInitialization`类的常量池中，以后`NotInitialization`对常量的引用，实际都被转化为`NotInitialization`对自身常量池的引用了。也就是说，实际上`NotInitialization`的Class文件里面并没有`ConstClass`类的符号引用了，这两个类在编译成Class文件之后就不再存在任何联系

## 3、详细分析类加载的过程

### 3.1 运行时常量池

虚拟机为每个类型都维护着一个常量池，该常量池是虚拟机中的运行时数据结构。当类或接口创建时，它的二进制表示中的==**常量池表**==被用来构造==**运行时常量池**==。运行时常量池中的所有引用最初都是符号引用。

在编译时，java类并不知道所引用的类的实际地址，因此只能用符号引用来代替。比如`org.simple.People`类引用了`org.simple.Language`类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号`org.simple.Language`来表示Language类的地址。

### 3.2 虚拟机启动

Java虚拟机的启动是通过引导类加载器（`bootstrap class loader`）创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的。紧接着，Java虚拟机链接这个初始化类，**初始化**它并**调用**它的`public`方法`void main(String[])`。

之后的整个执行过程都是由对此方法的调用开始的。执行main方法中的Java指令可能会导致Java虚拟机链接另外的一些类或接口，也可能会令虚拟机调用另外的方法。

也就是说，==首先加载的是main方法所在的类，这个类有一个运行时常量池，在运行时常量池中存在引用的其他类的全限定名等信息==

### 3.3 加载

加载是根据特定名称查找类或接口类型的二进制表示，并由此二进制表示来创建类或接口的过程。

在**加载阶段**，虚拟机要完成下面三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流（**全限定名从运行时常量池中得到**）
2. 将这个字节流所代表的静态存储结构转化为**==方法区的运行时数据结构==**
3. 在内存中生成一个==代表这个类的`java.lang.Class`对象==，作为方法区这个类的各种数据的访问入口（这个对象也存放到Java堆中，反射的时候就会用到这个类）

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在**==方法区==**之中了，方法区中的数据存储格式完全由虚拟机实现自行定义。

加载阶段和连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

### 3.4 验证

验证的目的是确保Class文件的字节流中包含的信息符合要求。其大致包括：文件格式验证、元数据验证、字节码验证和符号引用验证。

1. 文件格式验证

   主要目的是保证输入的字节流能正确地解析并存储于方法区中，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的**方法区**中进行存储，所以**后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。**

2. 元数据验证

   对元数据的信息进行语义校验

3. 字节码验证

   通过数据流分析和控制流分析，确定程序语义时合法的、符合逻辑的，也就是要对方法体进行校验。

4. 符号引用校验

   这个校验行为发生在虚拟机将符号引用转换为直接引用的时候，这个转化动作将在连接的第三个阶段——==解析==阶段中发生。目的是保证解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个`java.lang.IncompatibleClassChangeError`的子类异常，典型的如：
   `java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`、`java.lang.NoSuchMethodError`等。

### 3.5 准备

准备阶段是正式为类中定义的变量（**==静态变量==**）分配内存并设置类变量初始值（**==零值==**）的阶段，这些变量所使用的内存都应该在**方法区中**进行分配

**注意**

==在准备阶段进行内存分配的仅包括类变量，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。==

### 3.6 解析

虚拟机将常量池内的符号引用替换为直接引用的阶段，符号引用在Class文件中它以`CONSTANT_Class_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info`等类型的常量出现

直接引用与符号引用的关联：

* 符号引用：以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可。**符号引用与虚拟机实现的内存无关**，引用的目标并不一定是已经加载到虚拟机内存中的内容。
* 直接引用：指可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直**接引用是和虚拟机实现的内存布局相关的**，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。

### 3.7 初始化

直到初始化阶段，**Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序**

在准备阶段，静态变量已经赋过一次系统要求的初试零值，而在初始化阶段，会根据程序员通过程序编码指定的主观计划去初始化类变量和其他资源。**==初始化对于一个类或接口来说，就是执行它的初始化方法，也就是执行类构造器<clinit>方法的过程。（<init>方法在创建类实例的时候执行，现在只是在加载类，所以只是初始化类变量和其他类资源）==**

* <clinit>方法是由编译器类中的所有**类变量的赋值动作**和**静态语句块中的语句**合并而成的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，**静态语句块只能访问到定义在静态语句块之前的变量**，定义在它后面的变量，在前面的静态语句块中可以赋值，但是不能访问

  ```java
  public class Test {
      static {
          i = 0; // 给变量复制可以正常编译通过
          System.out.print(i); // 这句编译器会提示“非法向前引用”
      }
      static int i = 1;
  }
  ```

* <clinit>方法与类的构造函数（<init>方法）不同，它不需要显示地调用父类构造器，**==Java虚拟机会保证在子类的<clinit>方法执行前，父类的<clinit>方法已经执行完毕==**。因此在Java虚拟机中第一个被执行的<clinit>方法的类型肯定是`java.lang.Object`

* 由于父类的<clinit>方法先执行，也就意味着**父类中定义的静态变量语句块要优先于子类的变量赋值操作**

  ```java
  static class Parent {
      public static int A = 1;
      static {
          A = 2;
      }
  }
  static class Sub extends Parent {
      public static int B = A;
  }
  public static void main(String[] args) {
      System.out.println(Sub.B);
  }
  
  //输出：2
  ```

* <clinit>方法对于类或接口来说并**不是必需的**，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>方法

* **接口中不能使用静态语句块**，但仍然有变量初始化的赋值操作，因此接口也会有<clinit>方法。但是接口中的<clinit>方法执行不需要先执行父接口中的方法，**只有当父接口中定义的变量被使用时，父接口才需要被初始化**。接口的实现类在初始化时也**不会执行接口的<clinit>方法**

## 4、双亲委派模型

**双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。**

双亲委派有啥好处呢？它使得类有了层次的划分。就拿`java.lang.Object`来说，你加载它经过一层层委托最终是由`Bootstrap ClassLoader`来加载的，也就是最终都是由`Bootstrap ClassLoader`去找`\lib`中rt.jar里面的`java.lang.Object`加载到JVM中。

这样如果有不法分子自己造了个`java.lang.Object`,里面嵌了不好的代码，如果我们是按照双亲委派模型来实现的话，最终加载到JVM中的只会是我们rt.jar里面的东西，也就是这些核心的基础类代码得到了保护。因为这个机制使得系统中只会出现一个`java.lang.Object`。不会乱套了。你想想如果我们JVM里面有两个Object,那岂不是天下大乱了。

因此既然推荐使用这种模型当然是有道理了。

但是人生不如意事十之八九，**有些情况不得不违反这个约束**，例如JDBC。

你先得知道SPI(Service Provider Interface)，这玩意和API不一样，它是面向拓展的，也就是我定义了这个SPI，具体如何实现由扩展者实现。我就是定了个规矩。

JDBC就是如此，在rt.jar里面定义了这个SPI，那mysql有mysql的jdbc实现，oracle有oracle的jdbc实现，反正我java不管你内部如何实现的，反正你们都得统一按我这个来，这样我们java开发者才能容易的调用数据库操作。所以因为这样那就不得不违反这个约束啊，`Bootstrap ClassLoader`就得委托子类来加载数据库厂商们提供的具体实现。因为它的手只能摸到`\lib`中，其他的它无能为力。这就违反了自下而上的委托机制了。

# 五、虚拟机字节码执行引擎

了解了class文件的结构组成、何时加载字节码文件以及整个加载过程之后，再来学习虚拟机是如何执行字节码的

## 1、方法调用

该阶段的唯一任务是**确定被调用方法的版本（确定调用哪一个方法）**，还没有涉及到方法内部的具体运行过程

### 1.1 解析

所有方法调用的目标方法在Class文件里面都是一个**常量池中的符号引用**，在类加载的**解析阶段**，会将其中一部分符号引用转化为直接引用，这种解析能够成立的前提是：**方法在程序真正执行之前就有一个可确定的版本，并且这个方法的调用版本在运行期是不可改变的**。也就是说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。

在Java中，符号“编译期可知、运行期不可变”的方法，主要有==**静态方法**==和==**私有方法**==两种，这两种方法都是不能被重写的。有5条方法调用字节码指令：

* `invokestatic`：用于调用静态方法
* `invokespecial`：用于调用实例构造器<init>()方法、私有方法和父类中的方法
* `invokevirtual`：用于调用所有的虚方法
* `invokeinterface`：用于调用接口方法，会在运行时再确定一个实现该接口的对象
* `invokedynamic`：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。

### 1.2 分派

分派调用会揭示“重载”和“重写”在Java虚拟机中是如何实现的，也就是虚拟机如何找到目标方法。

#### 1. 静态分派（方法重载解析）

```java
/**
* 方法静态分派演示
* @author zzm
*/
public class StaticDispatch {
    static abstract class Human {
    }
    static class Man extends Human {
    }
    static class Woman extends Human {
    }
    public void sayHello(Human guy) {
        System.out.println("hello,guy!");
    }
    public void sayHello(Man guy) {
        System.out.println("hello,gentleman!");
    }
    public void sayHello(Woman guy) {
        System.out.println("hello,lady!");
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}

//输出：
// 	  hello,guy!
//	  hello,guy!
```

我们把上面代码中的`Human`称为变量的**静态类型**，后面的`Man`被称为**实际类型**或**运行时类型**。静态类型和实际类型在运行过程中都可能发生变化，**区别**在于==**静态类型的变化仅仅在使用时发生**，变量本身的静态类型不会改变，并且**最终的静态类型是在编译期可知的**==；而==实际类型变化的结果再运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。==

```java
// 实际类型变化
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
// 静态类型变化
sr.sayHello((Man) human)
sr.sayHello((Woman) human)
```

对象human的实际类型是可变的，编译期间它完全是个“薛定谔的人”，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。

所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。**静态分派最典型应用表现就是重载。**

#### 2. 动态分派

**动态分派与重写相关**

```java
/**
* 方法动态分派演示
* @author zzm
*/
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }
    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        }
    }
    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        }
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
//输出：
//man say hello
//woman say hello
//woman say hello
```

`invokevirtual`指令的运行时解析过程大致分为以下几步：

1. 找到操作数栈顶的第一个元素所指向的对象的==**实际类型**==，记作C
2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的**直接引用**，查找过程结束；不通过则返回`java.lang.IllegalAccessError`异常
3. 否则，按照继承关系，从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常

因为`invokevirtual`指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的
invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中==**方法重写的本质**==。

在Java里面只有虚方法存在，字段永远不可能是虚的，换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。

```java
/**
* 字段不参与多态
* @author zzm
*/
public class FieldHasNoPolymorphic {
    static class Father {
        public int money = 1;
        public Father() {
            money = 2;
            showMeTheMoney();
        }
        public void showMeTheMoney() {
            System.out.println("I am Father, i have $" + money);
        }
    }
    static class Son extends Father {
        public int money = 3;
        public Son() {
            money = 4;
            showMeTheMoney();
        }
        public void showMeTheMoney() {
            System.out.println("I am Son, i have $" + money);
        }
    }
    public static void main(String[] args) {
        Father gay = new Son();
        System.out.println("This gay has $" + gay.money);
    }
}

/*
	输出：
		I am Son, i have $0
		I am Son, i have $4
		This gay has $2
*/
```

输出两句都是“I am Son”，这是因为Son类在创建的时候，首先隐式调用了Father的构造函数，而Father构造函数中对showMeTheMoney()的调用是一次虚方法调用，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”，这点经过前面的分析相信读者是没有疑问的了。而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是子类的money字段，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。main()的最后一句通过静态类型访问到了父类中的money，输出了2。

#### 3. 单分派与多分派

方法的**接收者**与方法的**参数**统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为但分派和多分派两种。

```java
/**
* 单分派、多分派演示
* @author zzm
*/
public class Dispatch {
    static class QQ {}
    static class _360 {}
    public static class Father {
        public void hardChoice(QQ arg) {
            System.out.println("father choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("father choose 360");
        }
    }
    public static class Son extends Father {
        public void hardChoice(QQ arg) {
            System.out.println("son choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("son choose 360");
        }
    }
    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}

father choose 360
son choose qq
```

# 六、锁优化

## 1、自旋锁和自适应自旋锁

### 1.1 自旋锁

原因：1、互斥同步会让线程挂起和恢复，这降低了并发程序的性能。2、共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程不值得

前提：物理机器有一个以上的处理器或者处理核心，能让**两个或以上的线程==同时==进行**

实现：让后面请求锁的那个线程“稍等一会儿”，**不放弃处理器的执行时间**，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需==**让线程执行一个忙循环（自旋）**==，这项技术就是所谓的**自旋锁**。

自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，==**如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。**==

### 1.2 锁消除

虚拟机即时编译器在运行时，对一些代码要求同步，但是**对被检测到不可能存在共享数据竞争的锁进行消除。**

### 1.3 锁粗化

如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个序列的外部。

### 1.4 偏向锁与==**一致性哈希码**==

一个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。**一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束**

![image-20200426102046906](F:\Java书和视频\笔记\images\jvm\11.png)

当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？

在Java语言里面**一个对象如果计算过哈希码**，就应该一直**保持该值不变**（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的==**一致性哈希码**==（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，**当一个对象已经计算过==一致性哈希码==后，它就再也无法进入偏向锁状态了**；而当一个**对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁**。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。

**注意**

这里说的计算请求应来自于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，如果重写了对象的hashCode()方法，计算哈希码时并不会产生这里所说的请求。