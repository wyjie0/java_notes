## 一、String、StringBuilder和StringBuffer的区别是什么？String为什么是不可变的？

**可变性**

String类中使用**final**关键字修饰**字符数组**来保存字符串，`private final char value[]`，所以String是不可变的。在Java9之后，String类的实现改用了byte数组存储字符串

而StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用**字符数组**保存字符串，但是没有用final修饰，所以这两种对象是**可变的**。

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，**是线程安全的**。AbstractStringBuilder是StringBuilder和StringBuffer的公共父类，定义了一些字符串的基本操作。**StringBuffer**对方法加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的。**StringBuilder**并没有对方法加同步锁，所以是**非线程安全**的。

**性能**

每次对String类型进行改变的时候，都会产生一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。但是由于StringBuffer对整个方法加锁，索引多线程情况下，性能并不是很好。

## 二、接口和抽象类的区别是什么？

1. **抽象类可以有构造方法**，接口不能有构造方法。抽象类和接口都不能被实例化
2. 抽象类可以有普通成员变量，接口没有普通成员变量
3. 抽象类中可以包含非抽象方法，接口中的所有方法必须是抽象的，不能有非抽象的普通方法
4. **抽象类中的抽象方法的访问类型可以是public，protected，但是接口中的方法必须是public**
5. **==抽象类中可以包含静态方法==，接口中不能包含静态方法**
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是`public static final`类型，并且默认即为该类型
7. 一个类可以实现多个接口，但是只能继承一个类
8. 从设计层面来讲，抽象是对类的抽象，是一种模板设计，而接口是行为的抽象，是一种行为的规范

jdk7~jdk9中接口概念的变化：

1. 在jdk7中接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现
2. jdk8中，接口可以有**默认方法**和**静态方法**
3. jdk9中，接口引入了**私有方法**和**私有静态方法**

## 三、==和equals（重要）

==：判断两个对象的地址是否相等。即，判断两个对象是否是同一个对象（基本数据类型比较的是值，引用类型比较的是地址）

equals()：判断两个对象是否相等，一般有两种使用情况：

* 类没有覆盖equals()方法，则通过equals()比较该类的两个对象时，等价于通过==比较这两个对象
* 类覆盖了equals()方法，我们一般都覆盖equals()方法来比较两个对象的内容是否相等。

**Object类中的equals()方法就是比较两个对象的地址是否相等**。

##  四、equals和hashcode（重要）

hashcode()和equals()的相关规定：

1. 如果两个对象相等（equals相等），则hashcode一定也是相同的
2. 两个对象相等，对两个对象调用equals方法，会返回true。也就是说，**equals方法可以确定的判断两个对象是否相等**
3. 如果两个对象的hashcode相等， 但这两个对象不一定相等；在map中进行查找的时候，首先通过hashcode来找到索引位置，然后通过equals方法来找到相等的对象
4. 如果equals方法被重写，一定也要重写hashcode 方法。因为equals可以确切判断两个对象是否相等，所以如果没有重写hashcode方法，那么在判断两个对象是否相等时，equals方法会返回true，而两个对象的hashcode却不相同。这样，在把数据存入到哈希表中时会有麻烦，因为首先通过hashcode方法指定索引，如果存放的是两个equals相等的对象，但是确会被放在哈希表的不同索引位置上，这又表示两个对象不相等。
5. 如果两个对象通过equals方法比较得到的结果是相等的，那么对这两个对象进行hashcode得到的值应该相同

## 五、线程有哪些基本状态

![image-20200508171545064](F:\Java书和视频\笔记\images\面试题\0.png)

![image-20200508171717975](F:\Java书和视频\笔记\images\面试题\1.png)

## 六、final关键字

final关键字主要用于三个地方：变量、方法、类

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则其在初始化之后便不能再指向另一个对象
2. 使用final方法的原因有两个：其一，把方法锁定，以防任何继承类修改它的含义，也就是说**子类不能重写父类的final方法**；其二是效率问题。类中所有private方法都隐式地被指定为final
3. 当用final修饰一个类的时候，表明**这个类不能被继承**。final类中的所有成员方法都会被隐式地指定为final方法

## 七、异常处理总结

* finally块：无论是否捕获或处理异常，finally块里的语句都会被执行。**当在try块或catch块中遇到return语句时，return后面的表达式先执行，然后执行finally块，最后执行return来返回。**

**在以下4种情况下，finally块不会被执行**：

1. 在finally语句块第一行发生了异常，因为在其他行，finally块还是会得到执行。
2. 在前面的代码中调用了System.exit(int)已推出了程序。但是如果该语句在异常语句之后，finally会执行
3. 程序所在的线程死亡
4. 关闭CPU

==**注意**==

当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容会被执行，并且**finally语句的返回值将会覆盖原始的返回值**：

```java
public static int f(int value) {
    try {
        return value * value;
    } finally {
        if (value == 2) {
            return 0;
        }
    }
}

如果调用f(2)，返回值将是0，因为finally语句的返回值覆盖了try中的返回值
```

## 八、Java中的IO流

<img src="F:\Java书和视频\笔记\images\面试题\2.png" alt="image-20200508173852949" style="zoom:200%;" />

<img src="F:\Java书和视频\笔记\images\面试题\3.png" alt="image-20200508173936909" style="zoom:200%;" />

## 九、BIO、NIO、AIO的区别

BIO：同步阻塞IO，数据的读取写入**必须阻塞在一个线程之内等待其完成**。在活动连接数不是特别高的情况下，这种模式还不错，但是不能处理高并发情景

NIO：同步非阻塞IO，提供了Channel、Selector、Buffer等抽象。它支持面向缓冲、通道的IO操作方法。

## 十、反射用到了哪些接口、哪些类？

* 类：

  Class（Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的）
  Constructor（反射获取各个构造器）
  Field（反射获取成员属性）
  Method（反射获取成员方法）

* 接口：

  Serializable、GenericDeclaration、Type、AnnotationElement

**反射机制中可以获取private成员的值，但是要通过设置(setAccessible(true))进行暴力反射，解除权限**